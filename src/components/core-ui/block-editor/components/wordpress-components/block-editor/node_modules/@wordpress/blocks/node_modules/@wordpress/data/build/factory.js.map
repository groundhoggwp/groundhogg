{"version":3,"sources":["@wordpress/data/src/factory.js"],"names":["createRegistrySelector","registrySelector","selector","registry","select","isRegistrySelector","createRegistryControl","registryControl","isRegistryControl"],"mappings":";;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCO,SAASA,sBAAT,CAAiCC,gBAAjC,EAAoD;AAC1D;AACA;AACA;AACA,MAAMC,QAAQ,GAAG,SAAXA,QAAW;AAAA,WAChBD,gBAAgB,CAAEC,QAAQ,CAACC,QAAT,CAAkBC,MAApB,CAAhB,yBADgB;AAAA,GAAjB;AAGA;;;;;;;;;AAOAF,EAAAA,QAAQ,CAACG,kBAAT,GAA8B,IAA9B;AAEA,SAAOH,QAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBO,SAASI,qBAAT,CAAgCC,eAAhC,EAAkD;AACxDA,EAAAA,eAAe,CAACC,iBAAhB,GAAoC,IAApC;AAEA,SAAOD,eAAP;AACA","sourcesContent":["/**\n * Creates a selector function that takes additional curried argument with the\n * registry `select` function. While a regular selector has signature\n * ```js\n * ( state, ...selectorArgs ) => ( result )\n * ```\n * that allows to select data from the store's `state`, a registry selector\n * has signature:\n * ```js\n * ( select ) => ( state, ...selectorArgs ) => ( result )\n * ```\n * that supports also selecting from other registered stores.\n *\n * @example\n * ```js\n * const getCurrentPostId = createRegistrySelector( ( select ) => ( state ) => {\n *   return select( 'core/editor' ).getCurrentPostId();\n * } );\n *\n * const getPostEdits = createRegistrySelector( ( select ) => ( state ) => {\n *   // calling another registry selector just like any other function\n *   const postType = getCurrentPostType( state );\n *   const postId = getCurrentPostId( state );\n *\t return select( 'core' ).getEntityRecordEdits( 'postType', postType, postId );\n * } );\n * ```\n *\n * Note how the `getCurrentPostId` selector can be called just like any other function,\n * (it works even inside a regular non-registry selector) and we don't need to pass the\n * registry as argument. The registry binding happens automatically when registering the selector\n * with a store.\n *\n * @param {Function} registrySelector Function receiving a registry `select`\n * function and returning a state selector.\n *\n * @return {Function} Registry selector that can be registered with a store.\n */\nexport function createRegistrySelector( registrySelector ) {\n\t// create a selector function that is bound to the registry referenced by `selector.registry`\n\t// and that has the same API as a regular selector. Binding it in such a way makes it\n\t// possible to call the selector directly from another selector.\n\tconst selector = ( ...args ) =>\n\t\tregistrySelector( selector.registry.select )( ...args );\n\n\t/**\n\t * Flag indicating that the selector is a registry selector that needs the correct registry\n\t * reference to be assigned to `selecto.registry` to make it work correctly.\n\t * be mapped as a registry selector.\n\t *\n\t * @type {boolean}\n\t */\n\tselector.isRegistrySelector = true;\n\n\treturn selector;\n}\n\n/**\n * Creates a control function that takes additional curried argument with the `registry` object.\n * While a regular control has signature\n * ```js\n * ( action ) => ( iteratorOrPromise )\n * ```\n * where the control works with the `action` that it's bound to, a registry control has signature:\n * ```js\n * ( registry ) => ( action ) => ( iteratorOrPromise )\n * ```\n * A registry control is typically used to select data or dispatch an action to a registered\n * store.\n *\n * When registering a control created with `createRegistryControl` with a store, the store\n * knows which calling convention to use when executing the control.\n *\n * @param {Function} registryControl Function receiving a registry object and returning a control.\n *\n * @return {Function} Registry control that can be registered with a store.\n */\nexport function createRegistryControl( registryControl ) {\n\tregistryControl.isRegistryControl = true;\n\n\treturn registryControl;\n}\n"]}