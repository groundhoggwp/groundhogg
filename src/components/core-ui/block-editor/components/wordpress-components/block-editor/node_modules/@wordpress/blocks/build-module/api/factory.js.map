{"version":3,"sources":["@wordpress/blocks/src/api/factory.js"],"names":["v4","uuid","every","reduce","castArray","findIndex","isObjectLike","filter","first","flatMap","has","uniq","isFunction","isEmpty","map","createHooks","applyFilters","getBlockType","getBlockTypes","getGroupingBlockName","normalizeBlockType","createBlock","name","attributes","innerBlocks","blockType","undefined","Error","sanitizedAttributes","accumulator","schema","key","value","hasOwnProperty","default","indexOf","source","Array","isArray","clientId","isValid","createBlocksFromInnerBlocksTemplate","innerBlocksOrTemplate","innerBlock","innerBlockTemplate","cloneBlock","block","mergeAttributes","newInnerBlocks","isPossibleTransformForSource","transform","direction","blocks","isMultiBlock","length","firstBlockName","isValidForMultiBlocks","isWildcardBlockTransform","isBlockType","type","sourceBlock","hasMatchingName","isContainerGroupBlock","blockName","isMatch","getBlockTypesForPossibleFromTransforms","allBlockTypes","blockTypesWithPossibleFromTransforms","fromTransforms","getBlockTransforms","findTransform","getBlockTypesForPossibleToTransforms","transformsTo","possibleTransforms","blockNames","transformation","t","includes","getPossibleBlockTransformations","blockTypesForFromTransforms","blockTypesForToTransforms","transforms","predicate","hooks","i","candidate","addFilter","toString","result","priority","blockTypeOrName","switchToBlockType","blocksArray","firstBlock","sourceName","transformationsFrom","transformationsTo","transformationResults","__experimentalConvert","currentBlock","some","firstSwitchedBlock","index","transformedBlock","getBlockFromExample","example"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { v4 as uuid } from 'uuid';\nimport {\n\tevery,\n\treduce,\n\tcastArray,\n\tfindIndex,\n\tisObjectLike,\n\tfilter,\n\tfirst,\n\tflatMap,\n\thas,\n\tuniq,\n\tisFunction,\n\tisEmpty,\n\tmap,\n} from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { createHooks, applyFilters } from '@wordpress/hooks';\n\n/**\n * Internal dependencies\n */\nimport {\n\tgetBlockType,\n\tgetBlockTypes,\n\tgetGroupingBlockName,\n} from './registration';\nimport { normalizeBlockType } from './utils';\n\n/**\n * Returns a block object given its type and attributes.\n *\n * @param {string} name        Block name.\n * @param {Object} attributes  Block attributes.\n * @param {?Array} innerBlocks Nested blocks.\n *\n * @return {Object} Block object.\n */\nexport function createBlock( name, attributes = {}, innerBlocks = [] ) {\n\t// Get the type definition associated with a registered block.\n\tconst blockType = getBlockType( name );\n\n\tif ( undefined === blockType ) {\n\t\tthrow new Error( `Block type '${ name }' is not registered.` );\n\t}\n\n\t// Ensure attributes contains only values defined by block type, and merge\n\t// default values for missing attributes.\n\tconst sanitizedAttributes = reduce(\n\t\tblockType.attributes,\n\t\t( accumulator, schema, key ) => {\n\t\t\tconst value = attributes[ key ];\n\n\t\t\tif ( undefined !== value ) {\n\t\t\t\taccumulator[ key ] = value;\n\t\t\t} else if ( schema.hasOwnProperty( 'default' ) ) {\n\t\t\t\taccumulator[ key ] = schema.default;\n\t\t\t}\n\n\t\t\tif ( [ 'node', 'children' ].indexOf( schema.source ) !== -1 ) {\n\t\t\t\t// Ensure value passed is always an array, which we're expecting in\n\t\t\t\t// the RichText component to handle the deprecated value.\n\t\t\t\tif ( typeof accumulator[ key ] === 'string' ) {\n\t\t\t\t\taccumulator[ key ] = [ accumulator[ key ] ];\n\t\t\t\t} else if ( ! Array.isArray( accumulator[ key ] ) ) {\n\t\t\t\t\taccumulator[ key ] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn accumulator;\n\t\t},\n\t\t{}\n\t);\n\n\tconst clientId = uuid();\n\n\t// Blocks are stored with a unique ID, the assigned type name, the block\n\t// attributes, and their inner blocks.\n\treturn {\n\t\tclientId,\n\t\tname,\n\t\tisValid: true,\n\t\tattributes: sanitizedAttributes,\n\t\tinnerBlocks,\n\t};\n}\n\n/**\n * Given an array of InnerBlocks templates or Block Objects,\n * returns an array of created Blocks from them.\n * It handles the case of having InnerBlocks as Blocks by\n * converting them to the proper format to continue recursively.\n *\n * @param {Array} innerBlocksOrTemplate Nested blocks or InnerBlocks templates.\n *\n * @return {Object[]} Array of Block objects.\n */\nexport function createBlocksFromInnerBlocksTemplate(\n\tinnerBlocksOrTemplate = []\n) {\n\treturn innerBlocksOrTemplate.map( ( innerBlock ) => {\n\t\tconst innerBlockTemplate = Array.isArray( innerBlock )\n\t\t\t? innerBlock\n\t\t\t: [\n\t\t\t\t\tinnerBlock.name,\n\t\t\t\t\tinnerBlock.attributes,\n\t\t\t\t\tinnerBlock.innerBlocks,\n\t\t\t  ];\n\t\tconst [ name, attributes, innerBlocks = [] ] = innerBlockTemplate;\n\t\treturn createBlock(\n\t\t\tname,\n\t\t\tattributes,\n\t\t\tcreateBlocksFromInnerBlocksTemplate( innerBlocks )\n\t\t);\n\t} );\n}\n\n/**\n * Given a block object, returns a copy of the block object, optionally merging\n * new attributes and/or replacing its inner blocks.\n *\n * @param {Object} block              Block instance.\n * @param {Object} mergeAttributes    Block attributes.\n * @param {?Array} newInnerBlocks     Nested blocks.\n *\n * @return {Object} A cloned block.\n */\nexport function cloneBlock( block, mergeAttributes = {}, newInnerBlocks ) {\n\tconst clientId = uuid();\n\n\treturn {\n\t\t...block,\n\t\tclientId,\n\t\tattributes: {\n\t\t\t...block.attributes,\n\t\t\t...mergeAttributes,\n\t\t},\n\t\tinnerBlocks:\n\t\t\tnewInnerBlocks ||\n\t\t\tblock.innerBlocks.map( ( innerBlock ) => cloneBlock( innerBlock ) ),\n\t};\n}\n\n/**\n * Returns a boolean indicating whether a transform is possible based on\n * various bits of context.\n *\n * @param {Object} transform The transform object to validate.\n * @param {string} direction Is this a 'from' or 'to' transform.\n * @param {Array} blocks The blocks to transform from.\n *\n * @return {boolean} Is the transform possible?\n */\nconst isPossibleTransformForSource = ( transform, direction, blocks ) => {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn false;\n\t}\n\n\t// If multiple blocks are selected, only multi block transforms\n\t// or wildcard transforms are allowed.\n\tconst isMultiBlock = blocks.length > 1;\n\tconst firstBlockName = first( blocks ).name;\n\tconst isValidForMultiBlocks =\n\t\tisWildcardBlockTransform( transform ) ||\n\t\t! isMultiBlock ||\n\t\ttransform.isMultiBlock;\n\tif ( ! isValidForMultiBlocks ) {\n\t\treturn false;\n\t}\n\n\t// Check non-wildcard transforms to ensure that transform is valid\n\t// for a block selection of multiple blocks of different types\n\tif (\n\t\t! isWildcardBlockTransform( transform ) &&\n\t\t! every( blocks, { name: firstBlockName } )\n\t) {\n\t\treturn false;\n\t}\n\n\t// Only consider 'block' type transforms as valid.\n\tconst isBlockType = transform.type === 'block';\n\tif ( ! isBlockType ) {\n\t\treturn false;\n\t}\n\n\t// Check if the transform's block name matches the source block (or is a wildcard)\n\t// only if this is a transform 'from'.\n\tconst sourceBlock = first( blocks );\n\tconst hasMatchingName =\n\t\tdirection !== 'from' ||\n\t\ttransform.blocks.indexOf( sourceBlock.name ) !== -1 ||\n\t\tisWildcardBlockTransform( transform );\n\tif ( ! hasMatchingName ) {\n\t\treturn false;\n\t}\n\n\t// Don't allow single Grouping blocks to be transformed into\n\t// a Grouping block.\n\tif (\n\t\t! isMultiBlock &&\n\t\tisContainerGroupBlock( sourceBlock.name ) &&\n\t\tisContainerGroupBlock( transform.blockName )\n\t) {\n\t\treturn false;\n\t}\n\n\t// If the transform has a `isMatch` function specified, check that it returns true.\n\tif ( isFunction( transform.isMatch ) ) {\n\t\tconst attributes = transform.isMultiBlock\n\t\t\t? blocks.map( ( block ) => block.attributes )\n\t\t\t: sourceBlock.attributes;\n\t\tif ( ! transform.isMatch( attributes ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * Returns block types that the 'blocks' can be transformed into, based on\n * 'from' transforms on other blocks.\n *\n * @param {Array}  blocks  The blocks to transform from.\n *\n * @return {Array} Block types that the blocks can be transformed into.\n */\nconst getBlockTypesForPossibleFromTransforms = ( blocks ) => {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn [];\n\t}\n\n\tconst allBlockTypes = getBlockTypes();\n\n\t// filter all blocks to find those with a 'from' transform.\n\tconst blockTypesWithPossibleFromTransforms = filter(\n\t\tallBlockTypes,\n\t\t( blockType ) => {\n\t\t\tconst fromTransforms = getBlockTransforms( 'from', blockType.name );\n\n\t\t\treturn !! findTransform( fromTransforms, ( transform ) => {\n\t\t\t\treturn isPossibleTransformForSource(\n\t\t\t\t\ttransform,\n\t\t\t\t\t'from',\n\t\t\t\t\tblocks\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\t);\n\n\treturn blockTypesWithPossibleFromTransforms;\n};\n\n/**\n * Returns block types that the 'blocks' can be transformed into, based on\n * the source block's own 'to' transforms.\n *\n * @param {Array} blocks The blocks to transform from.\n *\n * @return {Array} Block types that the source can be transformed into.\n */\nconst getBlockTypesForPossibleToTransforms = ( blocks ) => {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn [];\n\t}\n\n\tconst sourceBlock = first( blocks );\n\tconst blockType = getBlockType( sourceBlock.name );\n\tconst transformsTo = getBlockTransforms( 'to', blockType.name );\n\n\t// filter all 'to' transforms to find those that are possible.\n\tconst possibleTransforms = filter( transformsTo, ( transform ) => {\n\t\treturn (\n\t\t\ttransform && isPossibleTransformForSource( transform, 'to', blocks )\n\t\t);\n\t} );\n\n\t// Build a list of block names using the possible 'to' transforms.\n\tconst blockNames = flatMap(\n\t\tpossibleTransforms,\n\t\t( transformation ) => transformation.blocks\n\t);\n\n\t// Map block names to block types.\n\treturn blockNames.map( ( name ) => getBlockType( name ) );\n};\n\n/**\n * Determines whether transform is a \"block\" type\n * and if so whether it is a \"wildcard\" transform\n * ie: targets \"any\" block type\n *\n * @param {Object} t the Block transform object\n *\n * @return {boolean} whether transform is a wildcard transform\n */\nexport const isWildcardBlockTransform = ( t ) =>\n\tt &&\n\tt.type === 'block' &&\n\tArray.isArray( t.blocks ) &&\n\tt.blocks.includes( '*' );\n\n/**\n * Determines whether the given Block is the core Block which\n * acts as a container Block for other Blocks as part of the\n * Grouping mechanics\n *\n * @param  {string} name the name of the Block to test against\n *\n * @return {boolean} whether or not the Block is the container Block type\n */\nexport const isContainerGroupBlock = ( name ) =>\n\tname === getGroupingBlockName();\n\n/**\n * Returns an array of block types that the set of blocks received as argument\n * can be transformed into.\n *\n * @param {Array} blocks Blocks array.\n *\n * @return {Array} Block types that the blocks argument can be transformed to.\n */\nexport function getPossibleBlockTransformations( blocks ) {\n\tif ( isEmpty( blocks ) ) {\n\t\treturn [];\n\t}\n\n\tconst blockTypesForFromTransforms = getBlockTypesForPossibleFromTransforms(\n\t\tblocks\n\t);\n\tconst blockTypesForToTransforms = getBlockTypesForPossibleToTransforms(\n\t\tblocks\n\t);\n\n\treturn uniq( [\n\t\t...blockTypesForFromTransforms,\n\t\t...blockTypesForToTransforms,\n\t] );\n}\n\n/**\n * Given an array of transforms, returns the highest-priority transform where\n * the predicate function returns a truthy value. A higher-priority transform\n * is one with a lower priority value (i.e. first in priority order). Returns\n * null if the transforms set is empty or the predicate function returns a\n * falsey value for all entries.\n *\n * @param {Object[]} transforms Transforms to search.\n * @param {Function} predicate  Function returning true on matching transform.\n *\n * @return {?Object} Highest-priority transform candidate.\n */\nexport function findTransform( transforms, predicate ) {\n\t// The hooks library already has built-in mechanisms for managing priority\n\t// queue, so leverage via locally-defined instance.\n\tconst hooks = createHooks();\n\n\tfor ( let i = 0; i < transforms.length; i++ ) {\n\t\tconst candidate = transforms[ i ];\n\t\tif ( predicate( candidate ) ) {\n\t\t\thooks.addFilter(\n\t\t\t\t'transform',\n\t\t\t\t'transform/' + i.toString(),\n\t\t\t\t( result ) => ( result ? result : candidate ),\n\t\t\t\tcandidate.priority\n\t\t\t);\n\t\t}\n\t}\n\n\t// Filter name is arbitrarily chosen but consistent with above aggregation.\n\treturn hooks.applyFilters( 'transform', null );\n}\n\n/**\n * Returns normal block transforms for a given transform direction, optionally\n * for a specific block by name, or an empty array if there are no transforms.\n * If no block name is provided, returns transforms for all blocks. A normal\n * transform object includes `blockName` as a property.\n *\n * @param {string}  direction Transform direction (\"to\", \"from\").\n * @param {string|Object} blockTypeOrName  Block type or name.\n *\n * @return {Array} Block transforms for direction.\n */\nexport function getBlockTransforms( direction, blockTypeOrName ) {\n\t// When retrieving transforms for all block types, recurse into self.\n\tif ( blockTypeOrName === undefined ) {\n\t\treturn flatMap( getBlockTypes(), ( { name } ) =>\n\t\t\tgetBlockTransforms( direction, name )\n\t\t);\n\t}\n\n\t// Validate that block type exists and has array of direction.\n\tconst blockType = normalizeBlockType( blockTypeOrName );\n\tconst { name: blockName, transforms } = blockType || {};\n\tif ( ! transforms || ! Array.isArray( transforms[ direction ] ) ) {\n\t\treturn [];\n\t}\n\n\t// Map transforms to normal form.\n\treturn transforms[ direction ].map( ( transform ) => ( {\n\t\t...transform,\n\t\tblockName,\n\t} ) );\n}\n\n/**\n * Switch one or more blocks into one or more blocks of the new block type.\n *\n * @param {Array|Object} blocks Blocks array or block object.\n * @param {string}       name   Block name.\n *\n * @return {?Array} Array of blocks or null.\n */\nexport function switchToBlockType( blocks, name ) {\n\tconst blocksArray = castArray( blocks );\n\tconst isMultiBlock = blocksArray.length > 1;\n\tconst firstBlock = blocksArray[ 0 ];\n\tconst sourceName = firstBlock.name;\n\n\t// Find the right transformation by giving priority to the \"to\"\n\t// transformation.\n\tconst transformationsFrom = getBlockTransforms( 'from', name );\n\tconst transformationsTo = getBlockTransforms( 'to', sourceName );\n\n\tconst transformation =\n\t\tfindTransform(\n\t\t\ttransformationsTo,\n\t\t\t( t ) =>\n\t\t\t\tt.type === 'block' &&\n\t\t\t\t( isWildcardBlockTransform( t ) ||\n\t\t\t\t\tt.blocks.indexOf( name ) !== -1 ) &&\n\t\t\t\t( ! isMultiBlock || t.isMultiBlock )\n\t\t) ||\n\t\tfindTransform(\n\t\t\ttransformationsFrom,\n\t\t\t( t ) =>\n\t\t\t\tt.type === 'block' &&\n\t\t\t\t( isWildcardBlockTransform( t ) ||\n\t\t\t\t\tt.blocks.indexOf( sourceName ) !== -1 ) &&\n\t\t\t\t( ! isMultiBlock || t.isMultiBlock )\n\t\t);\n\n\t// Stop if there is no valid transformation.\n\tif ( ! transformation ) {\n\t\treturn null;\n\t}\n\n\tlet transformationResults;\n\n\tif ( transformation.isMultiBlock ) {\n\t\tif ( has( transformation, '__experimentalConvert' ) ) {\n\t\t\ttransformationResults = transformation.__experimentalConvert(\n\t\t\t\tblocksArray\n\t\t\t);\n\t\t} else {\n\t\t\ttransformationResults = transformation.transform(\n\t\t\t\tblocksArray.map( ( currentBlock ) => currentBlock.attributes ),\n\t\t\t\tblocksArray.map( ( currentBlock ) => currentBlock.innerBlocks )\n\t\t\t);\n\t\t}\n\t} else if ( has( transformation, '__experimentalConvert' ) ) {\n\t\ttransformationResults = transformation.__experimentalConvert(\n\t\t\tfirstBlock\n\t\t);\n\t} else {\n\t\ttransformationResults = transformation.transform(\n\t\t\tfirstBlock.attributes,\n\t\t\tfirstBlock.innerBlocks\n\t\t);\n\t}\n\n\t// Ensure that the transformation function returned an object or an array\n\t// of objects.\n\tif ( ! isObjectLike( transformationResults ) ) {\n\t\treturn null;\n\t}\n\n\t// If the transformation function returned a single object, we want to work\n\t// with an array instead.\n\ttransformationResults = castArray( transformationResults );\n\n\t// Ensure that every block object returned by the transformation has a\n\t// valid block type.\n\tif (\n\t\ttransformationResults.some(\n\t\t\t( result ) => ! getBlockType( result.name )\n\t\t)\n\t) {\n\t\treturn null;\n\t}\n\n\tconst firstSwitchedBlock = findIndex(\n\t\ttransformationResults,\n\t\t( result ) => result.name === name\n\t);\n\n\t// Ensure that at least one block object returned by the transformation has\n\t// the expected \"destination\" block type.\n\tif ( firstSwitchedBlock < 0 ) {\n\t\treturn null;\n\t}\n\n\treturn transformationResults.map( ( result, index ) => {\n\t\tconst transformedBlock = {\n\t\t\t...result,\n\t\t\t// The first transformed block whose type matches the \"destination\"\n\t\t\t// type gets to keep the existing client ID of the first block.\n\t\t\tclientId:\n\t\t\t\tindex === firstSwitchedBlock\n\t\t\t\t\t? firstBlock.clientId\n\t\t\t\t\t: result.clientId,\n\t\t};\n\n\t\t/**\n\t\t * Filters an individual transform result from block transformation.\n\t\t * All of the original blocks are passed, since transformations are\n\t\t * many-to-many, not one-to-one.\n\t\t *\n\t\t * @param {Object}   transformedBlock The transformed block.\n\t\t * @param {Object[]} blocks           Original blocks transformed.\n\t\t */\n\t\treturn applyFilters(\n\t\t\t'blocks.switchToBlockType.transformedBlock',\n\t\t\ttransformedBlock,\n\t\t\tblocks\n\t\t);\n\t} );\n}\n\n/**\n * Create a block object from the example API.\n *\n * @param {string} name\n * @param {Object} example\n *\n * @return {Object} block.\n */\nexport const getBlockFromExample = ( name, example ) => {\n\treturn createBlock(\n\t\tname,\n\t\texample.attributes,\n\t\tmap( example.innerBlocks, ( innerBlock ) =>\n\t\t\tgetBlockFromExample( innerBlock.name, innerBlock )\n\t\t)\n\t);\n};\n"]}