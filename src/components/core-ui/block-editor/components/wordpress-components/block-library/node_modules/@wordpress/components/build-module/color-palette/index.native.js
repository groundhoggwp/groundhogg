import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { ScrollView, TouchableWithoutFeedback, View, Animated, Easing, Dimensions, Platform, Text } from 'react-native';
import { map, uniq } from 'lodash';
/**
 * WordPress dependencies
 */

import { __ } from '@wordpress/i18n';
import { useRef, useEffect } from '@wordpress/element';
import { usePreferredColorSchemeStyle } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import styles from './style.scss';
import ColorIndicator from '../color-indicator';
import { colorsUtils } from '../mobile/color-settings/utils';
var ANIMATION_DURATION = 200;
var contentWidth = 0;
var scrollPosition = 0;
var customIndicatorWidth = 0;

function ColorPalette(_ref) {
  var setColor = _ref.setColor,
      activeColor = _ref.activeColor,
      isGradientColor = _ref.isGradientColor,
      defaultSettings = _ref.defaultSettings,
      currentSegment = _ref.currentSegment,
      onCustomPress = _ref.onCustomPress,
      shouldEnableBottomSheetScroll = _ref.shouldEnableBottomSheetScroll,
      _ref$shouldShowCustom = _ref.shouldShowCustomIndicatorOption,
      shouldShowCustomIndicatorOption = _ref$shouldShowCustom === void 0 ? true : _ref$shouldShowCustom,
      _ref$shouldShowCustom2 = _ref.shouldShowCustomLabel,
      shouldShowCustomLabel = _ref$shouldShowCustom2 === void 0 ? true : _ref$shouldShowCustom2,
      _ref$shouldShowCustom3 = _ref.shouldShowCustomVerticalSeparator,
      shouldShowCustomVerticalSeparator = _ref$shouldShowCustom3 === void 0 ? true : _ref$shouldShowCustom3,
      customColorIndicatorStyles = _ref.customColorIndicatorStyles,
      customIndicatorWrapperStyles = _ref.customIndicatorWrapperStyles;
  var customSwatchGradients = ['linear-gradient(120deg, rgba(255,0,0,.8), 0%, rgba(255,255,255,1) 70.71%)', 'linear-gradient(240deg, rgba(0,255,0,.8), 0%, rgba(0,255,0,0) 70.71%)', 'linear-gradient(360deg, rgba(0,0,255,.8), 0%, rgba(0,0,255,0) 70.71%)'];
  var scrollViewRef = useRef();
  var isIOS = Platform.OS === 'ios';
  var isGradientSegment = currentSegment === colorsUtils.segments[1];
  var scale = useRef(new Animated.Value(1)).current;
  var opacity = useRef(new Animated.Value(1)).current;
  var defaultColors = uniq(map(defaultSettings.colors, 'color'));
  var defaultGradientColors = uniq(map(defaultSettings.gradients, 'gradient'));
  var colors = isGradientSegment ? defaultGradientColors : defaultColors;
  var customIndicatorColor = isGradientSegment ? activeColor : customSwatchGradients;
  var isCustomGradientColor = isGradientColor && isSelectedCustom();
  var shouldShowCustomIndicator = shouldShowCustomIndicatorOption && (!isGradientSegment || isCustomGradientColor);
  var accessibilityHint = isGradientSegment ? __('Navigates to customize the gradient') : __('Navigates to custom color picker');

  var customText = __('Custom');

  useEffect(function () {
    if (scrollViewRef.current) {
      if (isSelectedCustom()) {
        scrollViewRef.current.scrollToEnd();
      } else {
        scrollViewRef.current.scrollTo({
          x: 0,
          y: 0
        });
      }
    }
  }, [currentSegment]);

  function isSelectedCustom() {
    var isWithinColors = activeColor && colors.includes(activeColor);

    if (activeColor) {
      if (isGradientSegment) {
        return isGradientColor && !isWithinColors;
      }

      return !isGradientColor && !isWithinColors;
    }

    return false;
  }

  function isSelected(color) {
    return !isSelectedCustom() && activeColor === color;
  }

  function timingAnimation(property, toValue) {
    return Animated.timing(property, {
      toValue: toValue,
      duration: ANIMATION_DURATION,
      easing: Easing.ease,
      useNativeDriver: true
    });
  }

  function performAnimation(color) {
    if (!isSelected(color)) {
      opacity.setValue(0);
    }

    Animated.parallel([timingAnimation(scale, 2), timingAnimation(opacity, 1)]).start(function () {
      opacity.setValue(1);
      scale.setValue(1);
    });
  }

  var scaleInterpolation = scale.interpolate({
    inputRange: [1, 1.5, 2],
    outputRange: [1, 0.7, 1]
  });

  function deselectCustomGradient() {
    var _Dimensions$get = Dimensions.get('window'),
        width = _Dimensions$get.width;

    var isVisible = contentWidth - scrollPosition - customIndicatorWidth < width;

    if (isCustomGradientColor) {
      if (!isIOS) {
        // Scroll position on Android doesn't adjust automatically when removing the last item from the horizontal list.
        // https://github.com/facebook/react-native/issues/27504
        // Workaround: Force the scroll when deselecting custom gradient color and when custom indicator is visible on layout.
        if (isCustomGradientColor && isVisible && scrollViewRef.current) {
          scrollViewRef.current.scrollTo({
            x: scrollPosition - customIndicatorWidth
          });
        }
      }
    }
  }

  function onColorPress(color) {
    deselectCustomGradient();
    performAnimation(color);
    setColor(color);
  }

  function onContentSizeChange(width) {
    contentWidth = width;

    if (isSelectedCustom() && scrollViewRef.current) {
      scrollViewRef.current.scrollToEnd({
        animated: !isIOS
      });
    }
  }

  function onCustomIndicatorLayout(_ref2) {
    var nativeEvent = _ref2.nativeEvent;
    var width = nativeEvent.layout.width;

    if (width !== customIndicatorWidth) {
      customIndicatorWidth = width;
    }
  }

  function onScroll(_ref3) {
    var nativeEvent = _ref3.nativeEvent;
    scrollPosition = nativeEvent.contentOffset.x;
  }

  var verticalSeparatorStyle = usePreferredColorSchemeStyle(styles.verticalSeparator, styles.verticalSeparatorDark);
  var customTextStyle = usePreferredColorSchemeStyle([styles.customText, !isIOS && styles.customTextAndroid], styles.customTextDark);
  var customIndicatorWrapperStyle = [styles.customIndicatorWrapper, customIndicatorWrapperStyles];
  return createElement(ScrollView, {
    contentContainerStyle: styles.contentContainer,
    style: styles.container,
    horizontal: true,
    showsHorizontalScrollIndicator: false,
    keyboardShouldPersistTaps: "always",
    disableScrollViewPanResponder: true,
    scrollEventThrottle: 16,
    onScroll: onScroll,
    onContentSizeChange: onContentSizeChange,
    onScrollBeginDrag: function onScrollBeginDrag() {
      return shouldEnableBottomSheetScroll(false);
    },
    onScrollEndDrag: function onScrollEndDrag() {
      return shouldEnableBottomSheetScroll(true);
    },
    ref: scrollViewRef
  }, colors.map(function (color) {
    var scaleValue = isSelected(color) ? scaleInterpolation : 1;
    return createElement(TouchableWithoutFeedback, {
      onPress: function onPress() {
        return onColorPress(color);
      },
      key: "".concat(color, "-").concat(isSelected(color)),
      accessibilityRole: 'button',
      accessibilityState: {
        selected: isSelected(color)
      },
      accessibilityHint: color
    }, createElement(Animated.View, {
      style: {
        transform: [{
          scale: scaleValue
        }]
      }
    }, createElement(ColorIndicator, {
      color: color,
      isSelected: isSelected(color),
      opacity: opacity,
      style: [styles.colorIndicator, customColorIndicatorStyles]
    })));
  }), shouldShowCustomIndicator && createElement(View, {
    style: customIndicatorWrapperStyle,
    onLayout: onCustomIndicatorLayout
  }, shouldShowCustomVerticalSeparator && createElement(View, {
    style: verticalSeparatorStyle
  }), createElement(TouchableWithoutFeedback, {
    onPress: onCustomPress,
    accessibilityRole: 'button',
    accessibilityState: {
      selected: isSelectedCustom()
    },
    accessibilityHint: accessibilityHint
  }, createElement(View, {
    style: customIndicatorWrapperStyle
  }, createElement(ColorIndicator, {
    withCustomPicker: !isGradientSegment,
    color: customIndicatorColor,
    isSelected: isSelectedCustom(),
    style: [styles.colorIndicator, customColorIndicatorStyles]
  }), shouldShowCustomLabel && createElement(Text, {
    style: customTextStyle
  }, isIOS ? customText : customText.toUpperCase())))));
}

export default ColorPalette;
//# sourceMappingURL=index.native.js.map