{"version":3,"sources":["@wordpress/components/src/utils/hooks/use-controlled-state.js"],"names":["useEffect","useState","isValueDefined","getDefinedValue","defaultOptions","initial","undefined","fallback","useControlledState","currentState","options","internalState","setInternalState","hasCurrentState","state","setState","nextState"],"mappings":";;;;;;;AAAA;;;AAGA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,oBAApC;AAEA;;;;AAGA,SAASC,cAAT,EAAyBC,eAAzB,QAAgD,WAAhD;AAEA,IAAMC,cAAc,GAAG;AACtBC,EAAAA,OAAO,EAAEC,SADa;;AAEtB;;;;AAIAC,EAAAA,QAAQ,EAAE;AANY,CAAvB;AASA;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,SAASC,kBAAT,CAA6BC,YAA7B,EAAsE;AAAA,MAA3BC,OAA2B,uEAAjBN,cAAiB;;AAAA,8DAClCA,cADkC,GACfM,OADe;AAAA,MAC7DL,OAD6D,yBAC7DA,OAD6D;AAAA,MACpDE,QADoD,yBACpDA,QADoD;;AAAA,kBAGzBN,QAAQ,CAAEQ,YAAF,CAHiB;AAAA;AAAA,MAG7DE,aAH6D;AAAA,MAG9CC,gBAH8C;;AAIrE,MAAMC,eAAe,GAAGX,cAAc,CAAEO,YAAF,CAAtC;AAEA;;;;AAGAT,EAAAA,SAAS,CAAE,YAAM;AAChB,QAAKa,eAAe,IAAIF,aAAxB,EAAwC;AACvCC,MAAAA,gBAAgB,CAAEN,SAAF,CAAhB;AACA;AACD,GAJQ,EAIN,CAAEO,eAAF,EAAmBF,aAAnB,CAJM,CAAT;AAMA,MAAMG,KAAK,GAAGX,eAAe,CAC5B,CAAEM,YAAF,EAAgBE,aAAhB,EAA+BN,OAA/B,CAD4B,EAE5BE,QAF4B,CAA7B;;AAKA,MAAMQ,QAAQ,GAAG,SAAXA,QAAW,CAAEC,SAAF,EAAiB;AACjC,QAAK,CAAEH,eAAP,EAAyB;AACxBD,MAAAA,gBAAgB,CAAEI,SAAF,CAAhB;AACA;AACD,GAJD;;AAMA,SAAO,CAAEF,KAAF,EAASC,QAAT,CAAP;AACA;;AAED,eAAeP,kBAAf","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useEffect, useState } from '@wordpress/element';\n\n/**\n * Internal dependencies\n */\nimport { isValueDefined, getDefinedValue } from '../values';\n\nconst defaultOptions = {\n\tinitial: undefined,\n\t/**\n\t * Defaults to empty string, as that is preferred for usage with\n\t * <input />, <textarea />, and <select /> form elements.\n\t */\n\tfallback: '',\n};\n\n/**\n * Custom hooks for \"controlled\" components to track and consolidate internal\n * state and incoming values. This is useful for components that render\n * `input`, `textarea`, or `select` HTML elements.\n *\n * https://reactjs.org/docs/forms.html#controlled-components\n *\n * At first, a component using useControlledState receives an initial prop\n * value, which is used as initial internal state.\n *\n * This internal state can be maintained and updated without\n * relying on new incoming prop values.\n *\n * Unlike the basic useState hook, useControlledState's state can\n * be updated if a new incoming prop value is changed.\n *\n * @param {any} currentState The current value.\n * @param {Object} options Additional options for the hook.\n * @param {any} options.initial The initial state.\n * @param {any} options.fallback The state to use when no state is defined.\n *\n * @return {[*, Function]} The controlled value and the value setter.\n */\nfunction useControlledState( currentState, options = defaultOptions ) {\n\tconst { initial, fallback } = { ...defaultOptions, ...options };\n\n\tconst [ internalState, setInternalState ] = useState( currentState );\n\tconst hasCurrentState = isValueDefined( currentState );\n\n\t/*\n\t * Resets internal state if value every changes from uncontrolled <-> controlled.\n\t */\n\tuseEffect( () => {\n\t\tif ( hasCurrentState && internalState ) {\n\t\t\tsetInternalState( undefined );\n\t\t}\n\t}, [ hasCurrentState, internalState ] );\n\n\tconst state = getDefinedValue(\n\t\t[ currentState, internalState, initial ],\n\t\tfallback\n\t);\n\n\tconst setState = ( nextState ) => {\n\t\tif ( ! hasCurrentState ) {\n\t\t\tsetInternalState( nextState );\n\t\t}\n\t};\n\n\treturn [ state, setState ];\n}\n\nexport default useControlledState;\n"]}