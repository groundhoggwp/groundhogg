import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import { createElement } from "@wordpress/element";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * External dependencies
 */
import { take, difference, each, identity } from 'lodash';
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { __, _n, sprintf } from '@wordpress/i18n';
import { Component } from '@wordpress/element';
import { withInstanceId } from '@wordpress/compose';
import { ENTER, UP, DOWN, LEFT, RIGHT, ESCAPE } from '@wordpress/keycodes';
import isShallowEqual from '@wordpress/is-shallow-equal';
/**
 * Internal dependencies
 */

import TokenInput from './token-input';
import SuggestionsList from './suggestions-list';
import withSpokenMessages from '../higher-order/with-spoken-messages';
var initialState = {
  incompleteTokenValue: '',
  isActive: false,
  isExpanded: false,
  selectedSuggestion: null
};

var ComboboxControl = /*#__PURE__*/function (_Component) {
  _inherits(ComboboxControl, _Component);

  var _super = _createSuper(ComboboxControl);

  function ComboboxControl() {
    var _this;

    _classCallCheck(this, ComboboxControl);

    _this = _super.apply(this, arguments);
    _this.state = initialState;
    _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized(_this));
    _this.onContainerTouched = _this.onContainerTouched.bind(_assertThisInitialized(_this));
    _this.onSuggestionHovered = _this.onSuggestionHovered.bind(_assertThisInitialized(_this));
    _this.onSuggestionSelected = _this.onSuggestionSelected.bind(_assertThisInitialized(_this));
    _this.onInputChange = _this.onInputChange.bind(_assertThisInitialized(_this));
    _this.bindInput = _this.bindInput.bind(_assertThisInitialized(_this));
    _this.bindTokensAndInput = _this.bindTokensAndInput.bind(_assertThisInitialized(_this));
    _this.updateSuggestions = _this.updateSuggestions.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(ComboboxControl, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      // Make sure to focus the input when the isActive state is true.
      if (this.state.isActive && !this.input.hasFocus()) {
        this.input.focus();
      }

      var _this$props = this.props,
          suggestions = _this$props.suggestions,
          value = _this$props.value;
      var suggestionsDidUpdate = !isShallowEqual(suggestions, prevProps.suggestions);

      if (suggestionsDidUpdate || value !== prevProps.value) {
        this.updateSuggestions();
      }
    }
  }, {
    key: "bindInput",
    value: function bindInput(ref) {
      this.input = ref;
    }
  }, {
    key: "bindTokensAndInput",
    value: function bindTokensAndInput(ref) {
      this.tokensAndInput = ref;
    }
  }, {
    key: "onFocus",
    value: function onFocus(event) {
      // If focus is on the input or on the container, set the isActive state to true.
      if (this.input.hasFocus() || event.target === this.tokensAndInput) {
        this.setState({
          isActive: true
        });
      } else {
        /*
         * Otherwise, focus is on one of the token "remove" buttons and we
         * set the isActive state to false to prevent the input to be
         * re-focused, see componentDidUpdate().
         */
        this.setState({
          isActive: false
        });
      }

      if ('function' === typeof this.props.onFocus) {
        this.props.onFocus(event);
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        isActive: false,
        incompleteTokenValue: this.props.value,
        isExpanded: false
      });
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      var preventDefault = false;

      switch (event.keyCode) {
        case ENTER:
          if (this.state.selectedSuggestion) {
            this.onSuggestionSelected(this.state.selectedSuggestion);
            preventDefault = true;
          }

          break;

        case LEFT:
          preventDefault = this.handleLeftArrowKey();
          break;

        case UP:
          preventDefault = this.handleUpArrowKey();
          break;

        case RIGHT:
          preventDefault = this.handleRightArrowKey();
          break;

        case DOWN:
          preventDefault = this.handleDownArrowKey();
          break;

        case ESCAPE:
          preventDefault = this.handleEscapeKey(event);
          event.stopPropagation();
          break;

        default:
          break;
      }

      if (preventDefault) {
        event.preventDefault();
      }
    }
  }, {
    key: "onContainerTouched",
    value: function onContainerTouched(event) {
      // Prevent clicking/touching the tokensAndInput container from blurring
      // the input and adding the current token.
      if (event.target === this.tokensAndInput && this.state.isActive) {
        event.preventDefault();
      }
    }
  }, {
    key: "onSuggestionHovered",
    value: function onSuggestionHovered(suggestion) {
      this.setState({
        selectedSuggestion: suggestion
      });
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(event) {
      var text = event.value;
      this.setState({
        incompleteTokenValue: text
      }, this.updateSuggestions);
      this.props.onInputChange(text);
    }
  }, {
    key: "handleUpArrowKey",
    value: function handleUpArrowKey() {
      var matchingSuggestions = this.getMatchingSuggestions();
      var index = matchingSuggestions.indexOf(this.state.selectedSuggestion);

      if (index === 0 || index === -1) {
        this.setState({
          selectedSuggestion: matchingSuggestions[matchingSuggestions.length - 1]
        });
      } else {
        this.setState({
          selectedSuggestion: matchingSuggestions[index - 1]
        });
      }

      return true; // preventDefault
    }
  }, {
    key: "handleDownArrowKey",
    value: function handleDownArrowKey() {
      var matchingSuggestions = this.getMatchingSuggestions();
      var index = matchingSuggestions.indexOf(this.state.selectedSuggestion);

      if (index === matchingSuggestions.length - 1 || index === -1) {
        this.setState({
          selectedSuggestion: matchingSuggestions[0]
        });
      } else {
        this.setState({
          selectedSuggestion: matchingSuggestions[index + 1]
        });
      }

      return true; // preventDefault
    }
  }, {
    key: "handleEscapeKey",
    value: function handleEscapeKey(event) {
      this.setState({
        incompleteTokenValue: event.target.value,
        isExpanded: false,
        selectedSuggestion: null
      });
      return true; // preventDefault
    }
  }, {
    key: "onSuggestionSelected",
    value: function onSuggestionSelected(newValue) {
      this.props.onChange(newValue);
      this.props.speak(this.props.messages.selected, 'assertive');

      if (this.state.isActive) {
        this.input.focus();
      }

      this.setState({
        incompleteTokenValue: newValue,
        selectedSuggestion: null,
        isExpanded: false
      });
    }
  }, {
    key: "getMatchingSuggestions",
    value: function getMatchingSuggestions() {
      var searchValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.incompleteTokenValue;
      var suggestions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.suggestions;
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.value;
      var maxSuggestions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.props.maxSuggestions;
      var saveTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.props.saveTransform;
      var match = saveTransform(searchValue);
      var startsWithMatch = [];
      var containsMatch = [];

      if (!match || match.length === 0) {
        suggestions = difference(suggestions, value);
      } else {
        match = match.toLocaleLowerCase();
        each(suggestions, function (suggestion) {
          var index = suggestion.toLocaleLowerCase().indexOf(match);

          if (index === 0) {
            startsWithMatch.push(suggestion);
          } else if (index > 0) {
            containsMatch.push(suggestion);
          }
        });
        suggestions = startsWithMatch.concat(containsMatch);
      }

      return take(suggestions, maxSuggestions);
    }
  }, {
    key: "updateSuggestions",
    value: function updateSuggestions() {
      var _this$state = this.state,
          incompleteTokenValue = _this$state.incompleteTokenValue,
          selectedSuggestion = _this$state.selectedSuggestion;
      var inputHasMinimumChars = !!incompleteTokenValue && incompleteTokenValue.trim().length > 1;
      var matchingSuggestions = this.getMatchingSuggestions(incompleteTokenValue);
      var hasMatchingSuggestions = matchingSuggestions.length > 0;
      var newState = {
        isExpanded: inputHasMinimumChars && hasMatchingSuggestions
      };

      if (matchingSuggestions.indexOf(selectedSuggestion) === -1) {
        newState.selectedSuggestion = null;
      }

      if (!incompleteTokenValue || matchingSuggestions.indexOf(this.props.value) === -1) {
        this.props.onChange(null);
      }

      this.setState(newState);

      if (inputHasMinimumChars) {
        var debouncedSpeak = this.props.debouncedSpeak;
        var message = hasMatchingSuggestions ? sprintf(
        /* translators: %d: number of results. */
        _n('%d result found, use up and down arrow keys to navigate.', '%d results found, use up and down arrow keys to navigate.', matchingSuggestions.length), matchingSuggestions.length) : __('No results.');
        debouncedSpeak(message, 'assertive');
      }
    }
  }, {
    key: "renderInput",
    value: function renderInput() {
      var _this$props2 = this.props,
          autoCapitalize = _this$props2.autoCapitalize,
          autoComplete = _this$props2.autoComplete,
          maxLength = _this$props2.maxLength,
          value = _this$props2.value,
          instanceId = _this$props2.instanceId;
      var matchingSuggestions = this.getMatchingSuggestions();
      var props = {
        instanceId: instanceId,
        autoCapitalize: autoCapitalize,
        autoComplete: autoComplete,
        ref: this.bindInput,
        key: 'input',
        disabled: this.props.disabled,
        value: this.state.incompleteTokenValue,
        onBlur: this.onBlur,
        isExpanded: this.state.isExpanded,
        selectedSuggestionIndex: matchingSuggestions.indexOf(this.state.selectedSuggestion)
      };

      if (!(maxLength && value.length >= maxLength)) {
        props = _objectSpread(_objectSpread({}, props), {}, {
          onChange: this.onInputChange
        });
      }

      return createElement(TokenInput, props);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          disabled = _this$props3.disabled,
          _this$props3$label = _this$props3.label,
          label = _this$props3$label === void 0 ? __('Select item') : _this$props3$label,
          instanceId = _this$props3.instanceId,
          className = _this$props3.className;
      var _this$state2 = this.state,
          isExpanded = _this$state2.isExpanded,
          selectedSuggestion = _this$state2.selectedSuggestion,
          incompleteTokenValue = _this$state2.incompleteTokenValue;
      var classes = classnames(className, 'components-form-token-field__input-container', {
        'is-active': this.state.isActive,
        'is-disabled': disabled
      });
      var tokenFieldProps = {
        className: 'components-form-token-field',
        tabIndex: '-1'
      };
      var matchingSuggestions = this.getMatchingSuggestions();

      if (!disabled) {
        tokenFieldProps = Object.assign({}, tokenFieldProps, {
          onKeyDown: this.onKeyDown,
          onFocus: this.onFocus
        });
      } // Disable reason: There is no appropriate role which describes the
      // input container intended accessible usability.
      // TODO: Refactor click detection to use blur to stop propagation.

      /* eslint-disable jsx-a11y/no-static-element-interactions */


      return createElement("div", tokenFieldProps, createElement("label", {
        htmlFor: "components-form-token-input-".concat(instanceId),
        className: "components-form-token-field__label"
      }, label), createElement("div", {
        ref: this.bindTokensAndInput,
        className: classes,
        tabIndex: "-1",
        onMouseDown: this.onContainerTouched,
        onTouchStart: this.onContainerTouched
      }, this.renderInput(), isExpanded && createElement(SuggestionsList, {
        instanceId: instanceId,
        match: this.props.saveTransform(incompleteTokenValue),
        displayTransform: this.props.displayTransform,
        suggestions: matchingSuggestions,
        selectedIndex: matchingSuggestions.indexOf(selectedSuggestion),
        onHover: this.onSuggestionHovered,
        onSelect: this.onSuggestionSelected
      })));
      /* eslint-enable jsx-a11y/no-static-element-interactions */
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (!props.disabled || !state.isActive) {
        return null;
      }

      return {
        isActive: false,
        incompleteTokenValue: ''
      };
    }
  }]);

  return ComboboxControl;
}(Component);

ComboboxControl.defaultProps = {
  suggestions: Object.freeze([]),
  maxSuggestions: 100,
  value: null,
  displayTransform: identity,
  saveTransform: identity,
  onChange: function onChange() {},
  onInputChange: function onInputChange() {},
  isBorderless: false,
  disabled: false,
  messages: {
    selected: __('Item selected.')
  }
};
export default withSpokenMessages(withInstanceId(ComboboxControl));
//# sourceMappingURL=combobox.js.map