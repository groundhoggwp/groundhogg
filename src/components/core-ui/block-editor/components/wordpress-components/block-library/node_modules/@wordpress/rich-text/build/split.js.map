{"version":3,"sources":["@wordpress/rich-text/src/split.js"],"names":["split","string","formats","replacements","text","start","end","splitAtSelection","arguments","nextStart","map","substring","startIndex","value","slice","length","undefined","endIndex","before","after"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { replace } from './replace';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [\n\t\t// Ensure newlines are trimmed.\n\t\treplace( before, /\\u2028+$/, '' ),\n\t\treplace( after, /^\\u2028+/, '' ),\n\t];\n}\n"]}