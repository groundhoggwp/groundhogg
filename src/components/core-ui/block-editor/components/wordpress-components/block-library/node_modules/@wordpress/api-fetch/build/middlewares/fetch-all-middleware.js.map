{"version":3,"sources":["@wordpress/api-fetch/src/middlewares/fetch-all-middleware.js"],"names":["modifyQuery","queryArgs","path","url","options","parseResponse","response","json","Promise","reject","parseLinkHeader","linkHeader","match","next","getNextPageUrl","headers","get","requestContainsUnboundedQuery","pathIsUnbounded","indexOf","urlIsUnbounded","fetchAllMiddleware","parse","per_page","results","Array","isArray","nextPage","mergedResults","concat","undefined","nextResponse","nextResults"],"mappings":";;;;;;;;;;;;;;;;;AAGA;;AAKA;;;;;;AAEA;AACA,IAAMA,WAAW,GAAG,SAAdA,WAAc,OAA6BC,SAA7B;AAAA,MAAIC,IAAJ,QAAIA,IAAJ;AAAA,MAAUC,GAAV,QAAUA,GAAV;AAAA,MAAkBC,OAAlB;AAAA,yCAChBA,OADgB;AAEnBD,IAAAA,GAAG,EAAEA,GAAG,IAAI,uBAAcA,GAAd,EAAmBF,SAAnB,CAFO;AAGnBC,IAAAA,IAAI,EAAEA,IAAI,IAAI,uBAAcA,IAAd,EAAoBD,SAApB;AAHK;AAAA,CAApB,C,CAMA;;;AACA,IAAMI,aAAa,GAAG,SAAhBA,aAAgB,CAAEC,QAAF;AAAA,SACrBA,QAAQ,CAACC,IAAT,GAAgBD,QAAQ,CAACC,IAAT,EAAhB,GAAkCC,OAAO,CAACC,MAAR,CAAgBH,QAAhB,CADb;AAAA,CAAtB;;AAGA,IAAMI,eAAe,GAAG,SAAlBA,eAAkB,CAAEC,UAAF,EAAkB;AACzC,MAAK,CAAEA,UAAP,EAAoB;AACnB,WAAO,EAAP;AACA;;AACD,MAAMC,KAAK,GAAGD,UAAU,CAACC,KAAX,CAAkB,uBAAlB,CAAd;AACA,SAAOA,KAAK,GACT;AACAC,IAAAA,IAAI,EAAED,KAAK,CAAE,CAAF;AADX,GADS,GAIT,EAJH;AAKA,CAVD;;AAYA,IAAME,cAAc,GAAG,SAAjBA,cAAiB,CAAER,QAAF,EAAgB;AAAA,yBACrBI,eAAe,CAAEJ,QAAQ,CAACS,OAAT,CAAiBC,GAAjB,CAAsB,MAAtB,CAAF,CADM;AAAA,MAC9BH,IAD8B,oBAC9BA,IAD8B;;AAEtC,SAAOA,IAAP;AACA,CAHD;;AAKA,IAAMI,6BAA6B,GAAG,SAAhCA,6BAAgC,CAAEb,OAAF,EAAe;AACpD,MAAMc,eAAe,GACpBd,OAAO,CAACF,IAAR,IAAgBE,OAAO,CAACF,IAAR,CAAaiB,OAAb,CAAsB,aAAtB,MAA0C,CAAC,CAD5D;AAEA,MAAMC,cAAc,GACnBhB,OAAO,CAACD,GAAR,IAAeC,OAAO,CAACD,GAAR,CAAYgB,OAAZ,CAAqB,aAArB,MAAyC,CAAC,CAD1D;AAEA,SAAOD,eAAe,IAAIE,cAA1B;AACA,CAND,C,CAQA;AACA;AACA;;;AACA,IAAMC,kBAAkB;AAAA,sFAAG,iBAAQjB,OAAR,EAAiBS,IAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACrBT,OAAO,CAACkB,KAAR,KAAkB,KADG;AAAA;AAAA;AAAA;;AAAA,6CAGlBT,IAAI,CAAET,OAAF,CAHc;;AAAA;AAAA,gBAKnBa,6BAA6B,CAAEb,OAAF,CALV;AAAA;AAAA;AAAA;;AAAA,6CAOlBS,IAAI,CAAET,OAAF,CAPc;;AAAA;AAAA;AAAA,mBAWH,+CACnBJ,WAAW,CAAEI,OAAF,EAAW;AACxBmB,cAAAA,QAAQ,EAAE;AADc,aAAX,CADQ;AAItB;AACAD,cAAAA,KAAK,EAAE;AALe,eAXG;;AAAA;AAWpBhB,YAAAA,QAXoB;AAAA;AAAA,mBAmBJD,aAAa,CAAEC,QAAF,CAnBT;;AAAA;AAmBpBkB,YAAAA,OAnBoB;;AAAA,gBAqBnBC,KAAK,CAACC,OAAN,CAAeF,OAAf,CArBmB;AAAA;AAAA;AAAA;;AAAA,6CAuBlBA,OAvBkB;;AAAA;AA0BtBG,YAAAA,QA1BsB,GA0BXb,cAAc,CAAER,QAAF,CA1BH;;AAAA,gBA4BnBqB,QA5BmB;AAAA;AAAA;AAAA;;AAAA,6CA8BlBH,OA9BkB;;AAAA;AAiC1B;AACII,YAAAA,aAlCsB,GAkCN,GAAGC,MAAH,CAAWL,OAAX,CAlCM;;AAAA;AAAA,iBAmClBG,QAnCkB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAoCE,+CACvBvB,OADuB;AAE1B;AACAF,cAAAA,IAAI,EAAE4B,SAHoB;AAI1B3B,cAAAA,GAAG,EAAEwB,QAJqB;AAK1B;AACAL,cAAAA,KAAK,EAAE;AANmB,eApCF;;AAAA;AAoCnBS,YAAAA,YApCmB;AAAA;AAAA,mBA4CC1B,aAAa,CAAE0B,YAAF,CA5Cd;;AAAA;AA4CnBC,YAAAA,WA5CmB;AA6CzBJ,YAAAA,aAAa,GAAGA,aAAa,CAACC,MAAd,CAAsBG,WAAtB,CAAhB;AACAL,YAAAA,QAAQ,GAAGb,cAAc,CAAEiB,YAAF,CAAzB;AA9CyB;AAAA;;AAAA;AAAA,6CAgDnBH,aAhDmB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAlBP,kBAAkB;AAAA;AAAA;AAAA,GAAxB;;eAmDeA,kB","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { addQueryArgs } from '@wordpress/url';\n\n/**\n * Internal dependencies\n */\nimport apiFetch from '..';\n\n// Apply query arguments to both URL and Path, whichever is present.\nconst modifyQuery = ( { path, url, ...options }, queryArgs ) => ( {\n\t...options,\n\turl: url && addQueryArgs( url, queryArgs ),\n\tpath: path && addQueryArgs( path, queryArgs ),\n} );\n\n// Duplicates parsing functionality from apiFetch.\nconst parseResponse = ( response ) =>\n\tresponse.json ? response.json() : Promise.reject( response );\n\nconst parseLinkHeader = ( linkHeader ) => {\n\tif ( ! linkHeader ) {\n\t\treturn {};\n\t}\n\tconst match = linkHeader.match( /<([^>]+)>; rel=\"next\"/ );\n\treturn match\n\t\t? {\n\t\t\t\tnext: match[ 1 ],\n\t\t  }\n\t\t: {};\n};\n\nconst getNextPageUrl = ( response ) => {\n\tconst { next } = parseLinkHeader( response.headers.get( 'link' ) );\n\treturn next;\n};\n\nconst requestContainsUnboundedQuery = ( options ) => {\n\tconst pathIsUnbounded =\n\t\toptions.path && options.path.indexOf( 'per_page=-1' ) !== -1;\n\tconst urlIsUnbounded =\n\t\toptions.url && options.url.indexOf( 'per_page=-1' ) !== -1;\n\treturn pathIsUnbounded || urlIsUnbounded;\n};\n\n// The REST API enforces an upper limit on the per_page option. To handle large\n// collections, apiFetch consumers can pass `per_page=-1`; this middleware will\n// then recursively assemble a full response array from all available pages.\nconst fetchAllMiddleware = async ( options, next ) => {\n\tif ( options.parse === false ) {\n\t\t// If a consumer has opted out of parsing, do not apply middleware.\n\t\treturn next( options );\n\t}\n\tif ( ! requestContainsUnboundedQuery( options ) ) {\n\t\t// If neither url nor path is requesting all items, do not apply middleware.\n\t\treturn next( options );\n\t}\n\n\t// Retrieve requested page of results.\n\tconst response = await apiFetch( {\n\t\t...modifyQuery( options, {\n\t\t\tper_page: 100,\n\t\t} ),\n\t\t// Ensure headers are returned for page 1.\n\t\tparse: false,\n\t} );\n\n\tconst results = await parseResponse( response );\n\n\tif ( ! Array.isArray( results ) ) {\n\t\t// We have no reliable way of merging non-array results.\n\t\treturn results;\n\t}\n\n\tlet nextPage = getNextPageUrl( response );\n\n\tif ( ! nextPage ) {\n\t\t// There are no further pages to request.\n\t\treturn results;\n\t}\n\n\t// Iteratively fetch all remaining pages until no \"next\" header is found.\n\tlet mergedResults = [].concat( results );\n\twhile ( nextPage ) {\n\t\tconst nextResponse = await apiFetch( {\n\t\t\t...options,\n\t\t\t// Ensure the URL for the next page is used instead of any provided path.\n\t\t\tpath: undefined,\n\t\t\turl: nextPage,\n\t\t\t// Ensure we still get headers so we can identify the next page.\n\t\t\tparse: false,\n\t\t} );\n\t\tconst nextResults = await parseResponse( nextResponse );\n\t\tmergedResults = mergedResults.concat( nextResults );\n\t\tnextPage = getNextPageUrl( nextResponse );\n\t}\n\treturn mergedResults;\n};\n\nexport default fetchAllMiddleware;\n"]}