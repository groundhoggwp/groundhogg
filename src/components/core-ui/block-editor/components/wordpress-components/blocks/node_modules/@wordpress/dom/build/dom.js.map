{"version":3,"sources":["@wordpress/dom/src/dom.js"],"names":["window","DOMParser","getComputedStyle","Node","TEXT_NODE","ELEMENT_NODE","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","isSelectionForward","selection","anchorNode","focusNode","anchorOffset","focusOffset","position","compareDocumentPosition","isEdge","container","isReverse","onlyVertical","tagName","selectionStart","selectionEnd","value","length","isContentEditable","getSelection","rangeCount","originalRange","getRangeAt","range","cloneRange","isForward","isCollapsed","collapse","rangeRect","getRectangleFromRange","computedStyle","lineHeight","parseInt","height","padding","buffer","containerRect","getBoundingClientRect","originalRangeRect","verticalEdge","top","bottom","direction","isReverseDir","x","left","right","y","testRange","hiddenCaretRangeFromPoint","document","side","testRect","Math","abs","isHorizontalEdge","isVerticalEdge","collapsed","startContainer","nodeName","parentNode","index","Array","from","childNodes","indexOf","createRange","setStart","setEnd","rect","getClientRects","padNode","createTextNode","insertNode","removeChild","computeCaretRect","placeCaretAtHorizontalEdge","focus","rangeTarget","selectNodeContents","removeAllRanges","addRange","caretRangeFromPoint","doc","caretPositionFromPoint","point","offsetNode","offset","originalZIndex","style","zIndex","originalPosition","placeCaretAtVerticalEdge","mayUseScroll","editableRect","contains","scrollIntoView","isTextField","element","contentEditable","nonTextInputs","includes","type","isNumberInput","valueAsNumber","documentHasTextSelection","inputFieldHasUncollapsedSelection","error","documentHasUncollapsedSelection","activeElement","documentHasSelection","isEntirelySelected","endContainer","startOffset","endOffset","lastChild","lastChildContentLength","nodeType","data","firstChild","getScrollContainer","node","scrollHeight","clientHeight","overflowY","test","getOffsetParent","closestElement","offsetParent","replace","processedNode","newNode","insertAfter","remove","referenceNode","insertBefore","nextSibling","unwrap","parent","replaceTag","ownerDocument","createElement","appendChild","replaceChild","wrap","__unstableStripHTML","html","parseFromString","body","textContent","cleanNodeList","nodeList","schema","inline","forEach","tag","toLowerCase","hasOwnProperty","isMatch","attributes","classes","children","require","allowEmpty","isEmpty","hasAttributes","name","removeAttribute","classList","mattchers","map","item","className","RegExp","noop","some","hasChildNodes","querySelector","join","child","nextElementSibling","every","nodeValue","trim","removeInvalidHTML","HTML","implementation","createHTMLDocument","innerHTML"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { includes, noop } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport { isPhrasingContent } from './phrasing-content';\n\n/**\n * Browser dependencies\n */\n\nconst { DOMParser, getComputedStyle } = window;\nconst {\n\tTEXT_NODE,\n\tELEMENT_NODE,\n\tDOCUMENT_POSITION_PRECEDING,\n\tDOCUMENT_POSITION_FOLLOWING,\n} = window.Node;\n\n/**\n * Returns true if the given selection object is in the forward direction, or\n * false otherwise.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {Selection} selection Selection object to check.\n *\n * @return {boolean} Whether the selection is forward.\n */\nfunction isSelectionForward( selection ) {\n\tconst { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\n\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\n\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\n\t// so bitwise operators are intended.\n\t/* eslint-disable no-bitwise */\n\t// Compare whether anchor node precedes focus node. If focus node (where\n\t// end of selection occurs) is after the anchor node, it is forward.\n\tif ( position & DOCUMENT_POSITION_PRECEDING ) {\n\t\treturn false;\n\t}\n\n\tif ( position & DOCUMENT_POSITION_FOLLOWING ) {\n\t\treturn true;\n\t}\n\t/* eslint-enable no-bitwise */\n\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\n\t// case compare offsets.\n\tif ( position === 0 ) {\n\t\treturn anchorOffset <= focusOffset;\n\t}\n\n\t// This should never be reached, but return true as default case.\n\treturn true;\n}\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {Element} container    Focusable element.\n * @param {boolean} isReverse    Set to true to check left, false to check right.\n * @param {boolean} onlyVertical Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nfunction isEdge( container, isReverse, onlyVertical ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\n\tif ( ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst originalRange = selection.getRangeAt( 0 );\n\tconst range = originalRange.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\trange.collapse( ! isForward );\n\t}\n\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\tconst computedStyle = window.getComputedStyle( container );\n\tconst lineHeight = parseInt( computedStyle.lineHeight, 10 ) || 0;\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge.\n\tif (\n\t\t! isCollapsed &&\n\t\trangeRect.height > lineHeight &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\tconst padding =\n\t\tparseInt(\n\t\t\tcomputedStyle[ `padding${ isReverse ? 'Top' : 'Bottom' }` ],\n\t\t\t10\n\t\t) || 0;\n\n\t// Calculate a buffer that is half the line height. In some browsers, the\n\t// selection rectangle may not fill the entire height of the line, so we add\n\t// 3/4 the line height to the selection rectangle to ensure that it is well\n\t// over its line boundary.\n\tconst buffer = ( 3 * parseInt( lineHeight, 10 ) ) / 4;\n\tconst containerRect = container.getBoundingClientRect();\n\tconst originalRangeRect = getRectangleFromRange( originalRange );\n\tconst verticalEdge = isReverse\n\t\t? containerRect.top + padding > originalRangeRect.top - buffer\n\t\t: containerRect.bottom - padding < originalRangeRect.bottom + buffer;\n\n\tif ( ! verticalEdge ) {\n\t\treturn false;\n\t}\n\n\tif ( onlyVertical ) {\n\t\treturn true;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst { direction } = computedStyle;\n\tconst isReverseDir = direction === 'rtl' ? ! isReverse : isReverse;\n\n\t// To calculate the horizontal position, we insert a test range and see if\n\t// this test range has the same horizontal position. This method proves to\n\t// be better than a DOM-based calculation, because it ignores empty text\n\t// nodes and a trailing line break element. In other words, we need to check\n\t// visual positioning, not DOM positioning.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse\n\t\t? containerRect.top + buffer\n\t\t: containerRect.bottom - buffer;\n\tconst testRange = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst side = isReverseDir ? 'left' : 'right';\n\tconst testRect = getRectangleFromRange( testRange );\n\n\t// Allow the position to be 1px off.\n\treturn Math.abs( testRect[ side ] - rangeRect[ side ] ) <= 1;\n}\n\n/**\n * Check whether the selection is horizontally at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check left, false for right.\n *\n * @return {boolean} True if at the horizontal edge, false if not.\n */\nexport function isHorizontalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse );\n}\n\n/**\n * Check whether the selection is vertically at the edge of the container.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse Set to true to check top, false for bottom.\n *\n * @return {boolean} True if at the vertical edge, false if not.\n */\nexport function isVerticalEdge( container, isReverse ) {\n\treturn isEdge( container, isReverse, true );\n}\n\n/**\n * Get the rectangle of a given Range.\n *\n * @param {Range} range The range.\n *\n * @return {DOMRect} The rectangle.\n */\nexport function getRectangleFromRange( range ) {\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\n\t// range; this a rectangle enclosing the union of the bounding rectangles\n\t// for all the elements in the range.\n\tif ( ! range.collapsed ) {\n\t\treturn range.getBoundingClientRect();\n\t}\n\n\tconst { startContainer } = range;\n\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\n\tif ( startContainer.nodeName === 'BR' ) {\n\t\tconst { parentNode } = startContainer;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf(\n\t\t\tstartContainer\n\t\t);\n\n\t\trange = document.createRange();\n\t\trange.setStart( parentNode, index );\n\t\trange.setEnd( parentNode, index );\n\t}\n\n\tlet rect = range.getClientRects()[ 0 ];\n\n\t// If the collapsed range starts (and therefore ends) at an element node,\n\t// `getClientRects` can be empty in some browsers. This can be resolved\n\t// by adding a temporary text node with zero-width space to the range.\n\t//\n\t// See: https://stackoverflow.com/a/6847328/995445\n\tif ( ! rect ) {\n\t\tconst padNode = document.createTextNode( '\\u200b' );\n\t\t// Do not modify the live range.\n\t\trange = range.cloneRange();\n\t\trange.insertNode( padNode );\n\t\trect = range.getClientRects()[ 0 ];\n\t\tpadNode.parentNode.removeChild( padNode );\n\t}\n\n\treturn rect;\n}\n\n/**\n * Get the rectangle for the selection in a container.\n *\n * @return {?DOMRect} The rectangle.\n */\nexport function computeCaretRect() {\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\treturn getRectangleFromRange( range );\n}\n\n/**\n * Places the caret at start or end of a given element.\n *\n * @param {Element} container Focusable element.\n * @param {boolean} isReverse True for end, false for start.\n */\nexport function placeCaretAtHorizontalEdge( container, isReverse ) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], container.tagName ) ) {\n\t\tcontainer.focus();\n\t\tif ( isReverse ) {\n\t\t\tcontainer.selectionStart = container.value.length;\n\t\t\tcontainer.selectionEnd = container.value.length;\n\t\t} else {\n\t\t\tcontainer.selectionStart = 0;\n\t\t\tcontainer.selectionEnd = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tcontainer.focus();\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn;\n\t}\n\n\t// Select on extent child of the container, not the container itself. This\n\t// avoids the selection always being `endOffset` of 1 when placed at end,\n\t// where `startContainer`, `endContainer` would always be container itself.\n\tconst rangeTarget = container[ isReverse ? 'lastChild' : 'firstChild' ];\n\n\t// If no range target, it implies that the container is empty. Focusing is\n\t// sufficient for caret to be placed correctly.\n\tif ( ! rangeTarget ) {\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = document.createRange();\n\n\trange.selectNodeContents( rangeTarget );\n\trange.collapse( ! isReverse );\n\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Polyfill.\n * Get a collapsed range for a given point.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n *\n * @param {Document} doc The document of the range.\n * @param {number}    x   Horizontal position within the current viewport.\n * @param {number}    y   Vertical position within the current viewport.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction caretRangeFromPoint( doc, x, y ) {\n\tif ( doc.caretRangeFromPoint ) {\n\t\treturn doc.caretRangeFromPoint( x, y );\n\t}\n\n\tif ( ! doc.caretPositionFromPoint ) {\n\t\treturn null;\n\t}\n\n\tconst point = doc.caretPositionFromPoint( x, y );\n\n\t// If x or y are negative, outside viewport, or there is no text entry node.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\n\tif ( ! point ) {\n\t\treturn null;\n\t}\n\n\tconst range = doc.createRange();\n\n\trange.setStart( point.offsetNode, point.offset );\n\trange.collapse( true );\n\n\treturn range;\n}\n\n/**\n * Get a collapsed range for a given point.\n * Gives the container a temporary high z-index (above any UI).\n * This is preferred over getting the UI nodes and set styles there.\n *\n * @param {Document} doc       The document of the range.\n * @param {number}    x         Horizontal position within the current viewport.\n * @param {number}    y         Vertical position within the current viewport.\n * @param {Element}  container Container in which the range is expected to be found.\n *\n * @return {?Range} The best range for the given point.\n */\nfunction hiddenCaretRangeFromPoint( doc, x, y, container ) {\n\tconst originalZIndex = container.style.zIndex;\n\tconst originalPosition = container.style.position;\n\n\t// A z-index only works if the element position is not static.\n\tcontainer.style.zIndex = '10000';\n\tcontainer.style.position = 'relative';\n\n\tconst range = caretRangeFromPoint( doc, x, y );\n\n\tcontainer.style.zIndex = originalZIndex;\n\tcontainer.style.position = originalPosition;\n\n\treturn range;\n}\n\n/**\n * Places the caret at the top or bottom of a given element.\n *\n * @param {Element} container           Focusable element.\n * @param {boolean} isReverse           True for bottom, false for top.\n * @param {DOMRect} [rect]              The rectangle to position the caret with.\n * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\n */\nexport function placeCaretAtVerticalEdge(\n\tcontainer,\n\tisReverse,\n\trect,\n\tmayUseScroll = true\n) {\n\tif ( ! container ) {\n\t\treturn;\n\t}\n\n\tif ( ! rect || ! container.isContentEditable ) {\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\t// Offset by a buffer half the height of the caret rect. This is needed\n\t// because caretRangeFromPoint may default to the end of the selection if\n\t// offset is too close to the edge. It's unclear how to precisely calculate\n\t// this threshold; it may be the padded area of some combination of line\n\t// height, caret height, and font size. The buffer offset is effectively\n\t// equivalent to a point at half the height of a line of text.\n\tconst buffer = rect.height / 2;\n\tconst editableRect = container.getBoundingClientRect();\n\tconst x = rect.left;\n\tconst y = isReverse\n\t\t? editableRect.bottom - buffer\n\t\t: editableRect.top + buffer;\n\n\tconst range = hiddenCaretRangeFromPoint( document, x, y, container );\n\n\tif ( ! range || ! container.contains( range.startContainer ) ) {\n\t\tif (\n\t\t\tmayUseScroll &&\n\t\t\t( ! range ||\n\t\t\t\t! range.startContainer ||\n\t\t\t\t! range.startContainer.contains( container ) )\n\t\t) {\n\t\t\t// Might be out of view.\n\t\t\t// Easier than attempting to calculate manually.\n\t\t\tcontainer.scrollIntoView( isReverse );\n\t\t\tplaceCaretAtVerticalEdge( container, isReverse, rect, false );\n\t\t\treturn;\n\t\t}\n\n\t\tplaceCaretAtHorizontalEdge( container, isReverse );\n\t\treturn;\n\t}\n\n\tconst selection = window.getSelection();\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n\tcontainer.focus();\n\t// Editable was already focussed, it goes back to old range...\n\t// This fixes it.\n\tselection.removeAllRanges();\n\tselection.addRange( range );\n}\n\n/**\n * Check whether the given element is a text field, where text field is defined\n * by the ability to select within the input, or that it is contenteditable.\n *\n * See: https://html.spec.whatwg.org/#textFieldSelection\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is an text field, false if not.\n */\nexport function isTextField( element ) {\n\tconst { nodeName, contentEditable } = element;\n\tconst nonTextInputs = [\n\t\t'button',\n\t\t'checkbox',\n\t\t'hidden',\n\t\t'file',\n\t\t'radio',\n\t\t'image',\n\t\t'range',\n\t\t'reset',\n\t\t'submit',\n\t\t'number',\n\t];\n\treturn (\n\t\t( nodeName === 'INPUT' && ! nonTextInputs.includes( element.type ) ) ||\n\t\tnodeName === 'TEXTAREA' ||\n\t\tcontentEditable === 'true'\n\t);\n}\n\n/**\n * Check whether the given element is an input field of type number\n * and has a valueAsNumber\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} True if the element is input and holds a number.\n */\nexport function isNumberInput( element ) {\n\tconst { nodeName, type, valueAsNumber } = element;\n\n\treturn nodeName === 'INPUT' && type === 'number' && !! valueAsNumber;\n}\n\n/**\n * Check whether the current document has selected text. This applies to ranges\n * of text in the document, and not selection inside <input> and <textarea>\n * elements.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasTextSelection() {\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\treturn range && ! range.collapsed;\n}\n\n/**\n * Check whether the given element, assumed an input field or textarea,\n * contains a (uncollapsed) selection of text.\n *\n * Note: this is perhaps an abuse of the term \"selection\", since these elements\n * manage selection differently and aren't covered by Selection#collapsed.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\n *\n * @param {HTMLElement} element The HTML element.\n *\n * @return {boolean} Whether the input/textareaa element has some \"selection\".\n */\nfunction inputFieldHasUncollapsedSelection( element ) {\n\tif ( ! isTextField( element ) && ! isNumberInput( element ) ) {\n\t\treturn false;\n\t}\n\ttry {\n\t\tconst { selectionStart, selectionEnd } = element;\n\n\t\treturn selectionStart !== null && selectionStart !== selectionEnd;\n\t} catch ( error ) {\n\t\t// Safari throws an exception when trying to get `selectionStart`\n\t\t// on non-text <input> elements (which, understandably, don't\n\t\t// have the text selection API). We catch this via a try/catch\n\t\t// block, as opposed to a more explicit check of the element's\n\t\t// input types, because of Safari's non-standard behavior. This\n\t\t// also means we don't have to worry about the list of input\n\t\t// types that support `selectionStart` changing as the HTML spec\n\t\t// evolves over time.\n\t\treturn false;\n\t}\n}\n\n/**\n * Check whether the current document has any sort of selection. This includes\n * ranges of text across elements and any selection inside <input> and\n * <textarea> elements.\n *\n * @return {boolean} Whether there is any sort of \"selection\" in the document.\n */\nexport function documentHasUncollapsedSelection() {\n\treturn (\n\t\tdocumentHasTextSelection() ||\n\t\tinputFieldHasUncollapsedSelection( document.activeElement )\n\t);\n}\n\n/**\n * Check whether the current document has a selection. This checks for both\n * focus in an input field and general text selection.\n *\n * @return {boolean} True if there is selection, false if not.\n */\nexport function documentHasSelection() {\n\treturn (\n\t\tisTextField( document.activeElement ) ||\n\t\tisNumberInput( document.activeElement ) ||\n\t\tdocumentHasTextSelection()\n\t);\n}\n\n/**\n * Check whether the contents of the element have been entirely selected.\n * Returns true if there is no possibility of selection.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} True if entirely selected, false if not.\n */\nexport function isEntirelySelected( element ) {\n\tif ( includes( [ 'INPUT', 'TEXTAREA' ], element.nodeName ) ) {\n\t\treturn (\n\t\t\telement.selectionStart === 0 &&\n\t\t\telement.value.length === element.selectionEnd\n\t\t);\n\t}\n\n\tif ( ! element.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst selection = window.getSelection();\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\n\n\tif ( ! range ) {\n\t\treturn true;\n\t}\n\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\n\n\tif (\n\t\tstartContainer === element &&\n\t\tendContainer === element &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === element.childNodes.length\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastChild = element.lastChild;\n\tconst lastChildContentLength =\n\t\tlastChild.nodeType === TEXT_NODE\n\t\t\t? lastChild.data.length\n\t\t\t: lastChild.childNodes.length;\n\n\treturn (\n\t\tstartContainer === element.firstChild &&\n\t\tendContainer === element.lastChild &&\n\t\tstartOffset === 0 &&\n\t\tendOffset === lastChildContentLength\n\t);\n}\n\n/**\n * Given a DOM node, finds the closest scrollable container node.\n *\n * @param {Element} node Node from which to start.\n *\n * @return {?Element} Scrollable container node, if found.\n */\nexport function getScrollContainer( node ) {\n\tif ( ! node ) {\n\t\treturn;\n\t}\n\n\t// Scrollable if scrollable height exceeds displayed...\n\tif ( node.scrollHeight > node.clientHeight ) {\n\t\t// ...except when overflow is defined to be hidden or visible\n\t\tconst { overflowY } = window.getComputedStyle( node );\n\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// Continue traversing\n\treturn getScrollContainer( node.parentNode );\n}\n\n/**\n * Returns the closest positioned element, or null under any of the conditions\n * of the offsetParent specification. Unlike offsetParent, this function is not\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\n *\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\n *\n * @param {Node} node Node from which to find offset parent.\n *\n * @return {?Node} Offset parent.\n */\nexport function getOffsetParent( node ) {\n\t// Cannot retrieve computed style or offset parent only anything other than\n\t// an element node, so find the closest element node.\n\tlet closestElement;\n\twhile ( ( closestElement = node.parentNode ) ) {\n\t\tif ( closestElement.nodeType === ELEMENT_NODE ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( ! closestElement ) {\n\t\treturn null;\n\t}\n\n\t// If the closest element is already positioned, return it, as offsetParent\n\t// does not otherwise consider the node itself.\n\tif ( getComputedStyle( closestElement ).position !== 'static' ) {\n\t\treturn closestElement;\n\t}\n\n\treturn closestElement.offsetParent;\n}\n\n/**\n * Given two DOM nodes, replaces the former with the latter in the DOM.\n *\n * @param {Element} processedNode Node to be removed.\n * @param {Element} newNode       Node to be inserted in its place.\n * @return {void}\n */\nexport function replace( processedNode, newNode ) {\n\tinsertAfter( newNode, processedNode.parentNode );\n\tremove( processedNode );\n}\n\n/**\n * Given a DOM node, removes it from the DOM.\n *\n * @param {Element} node Node to be removed.\n * @return {void}\n */\nexport function remove( node ) {\n\tnode.parentNode.removeChild( node );\n}\n\n/**\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\n * the latter.\n *\n * @param {Element} newNode       Node to be inserted.\n * @param {Element} referenceNode Node after which to perform the insertion.\n * @return {void}\n */\nexport function insertAfter( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\n}\n\n/**\n * Unwrap the given node. This means any child nodes are moved to the parent.\n *\n * @param {Node} node The node to unwrap.\n *\n * @return {void}\n */\nexport function unwrap( node ) {\n\tconst parent = node.parentNode;\n\n\twhile ( node.firstChild ) {\n\t\tparent.insertBefore( node.firstChild, node );\n\t}\n\n\tparent.removeChild( node );\n}\n\n/**\n * Replaces the given node with a new node with the given tag name.\n *\n * @param {Element}  node    The node to replace\n * @param {string}   tagName The new tag name.\n *\n * @return {Element} The new node.\n */\nexport function replaceTag( node, tagName ) {\n\tconst newNode = node.ownerDocument.createElement( tagName );\n\n\twhile ( node.firstChild ) {\n\t\tnewNode.appendChild( node.firstChild );\n\t}\n\n\tnode.parentNode.replaceChild( newNode, node );\n\n\treturn newNode;\n}\n\n/**\n * Wraps the given node with a new node with the given tag name.\n *\n * @param {Element} newNode       The node to insert.\n * @param {Element} referenceNode The node to wrap.\n */\nexport function wrap( newNode, referenceNode ) {\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\n\tnewNode.appendChild( referenceNode );\n}\n\n/**\n * Removes any HTML tags from the provided string.\n *\n * @param {string} html The string containing html.\n *\n * @return {string} The text content with any html removed.\n */\nexport function __unstableStripHTML( html ) {\n\tconst document = new DOMParser().parseFromString( html, 'text/html' );\n\treturn document.body.textContent || '';\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Object}   schema   An array of functions that can mutate with the provided node.\n * @param {Object}   inline   Whether to clean for inline mode.\n */\nfunction cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach( ( node ) => {\n\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t// function, or with an isMatch function that matches the node.\n\t\tif (\n\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch( node ) )\n\t\t) {\n\t\t\tif ( node.nodeType === ELEMENT_NODE ) {\n\t\t\t\tconst {\n\t\t\t\t\tattributes = [],\n\t\t\t\t\tclasses = [],\n\t\t\t\t\tchildren,\n\t\t\t\t\trequire = [],\n\t\t\t\t\tallowEmpty,\n\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t// remove the node.\n\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\tremove( node );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t! includes( attributes, name )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\treturn ( className ) => className === item;\n\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\treturn ( className ) => item.test( className );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t( child ) => ! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t} else {\n\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t// are not phrasing content.\n\t\t\tif (\n\t\t\t\tinline &&\n\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\tnode.nextElementSibling\n\t\t\t) {\n\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t}\n\n\t\t\tunwrap( node );\n\t\t}\n\t} );\n}\n\n/**\n * Recursively checks if an element is empty. An element is not empty if it\n * contains text or contains elements with attributes such as images.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} Wether or not the element is empty.\n */\nexport function isEmpty( element ) {\n\tif ( ! element.hasChildNodes() ) {\n\t\treturn true;\n\t}\n\n\treturn Array.from( element.childNodes ).every( ( node ) => {\n\t\tif ( node.nodeType === TEXT_NODE ) {\n\t\t\treturn ! node.nodeValue.trim();\n\t\t}\n\n\t\tif ( node.nodeType === ELEMENT_NODE ) {\n\t\t\tif ( node.nodeName === 'BR' ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( node.hasAttributes() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEmpty( node );\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on HTML.\n *\n * @param {string} HTML   The HTML to clean up.\n * @param {Object} schema Schema for the HTML.\n * @param {Object} inline Whether to clean for inline mode.\n *\n * @return {string} The cleaned up HTML.\n */\nexport function removeInvalidHTML( HTML, schema, inline ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tcleanNodeList( doc.body.childNodes, doc, schema, inline );\n\n\treturn doc.body.innerHTML;\n}\n"]}