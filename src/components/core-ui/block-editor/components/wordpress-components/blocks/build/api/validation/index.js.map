{"version":3,"sources":["@wordpress/blocks/src/api/validation/index.js"],"names":["REGEXP_WHITESPACE","REGEXP_ONLY_WHITESPACE","REGEXP_STYLE_URL_TYPE","BOOLEAN_ATTRIBUTES","ENUMERATED_ATTRIBUTES","MEANINGFUL_ATTRIBUTES","TEXT_NORMALIZATIONS","identity","getTextWithCollapsedWhitespace","REGEXP_NAMED_CHARACTER_REFERENCE","REGEXP_DECIMAL_CHARACTER_REFERENCE","REGEXP_HEXADECIMAL_CHARACTER_REFERENCE","isValidCharacterReference","text","test","DecodeEntityParser","entity","getTextPiecesSplitOnWhitespace","trim","split","join","getMeaningfulAttributePairs","token","attributes","filter","pair","key","value","indexOf","isEquivalentTextTokens","actual","expected","logger","actualChars","chars","expectedChars","i","length","normalize","warning","getNormalizedStyleValue","replace","getStyleProperties","pairs","map","style","valueParts","isEqualAttributesOfName","class","xor","isEqual","attribute","stubTrue","isEqualTagAttributePairs","expectedAttributes","toLowerCase","name","actualValue","nameLower","hasOwnProperty","expectedValue","isEqualAttributes","isEqualTokensOfType","StartTag","tagName","Chars","Comment","getNextNonWhitespaceToken","tokens","shift","type","getHTMLTokens","html","Tokenizer","tokenize","e","isClosedByToken","currentToken","nextToken","selfClosing","isEquivalentHTML","actualTokens","expectedTokens","actualToken","expectedToken","isEqualTokens","getBlockContentValidationResult","blockTypeOrName","originalBlockContent","blockType","generatedBlockContent","error","toString","isValid","validationIssues","getItems","isValidBlockContent"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { Tokenizer } from 'simple-html-tokenizer';\nimport { identity, xor, fromPairs, isEqual, includes, stubTrue } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { decodeEntities } from '@wordpress/html-entities';\n\n/**\n * Internal dependencies\n */\nimport { createLogger, createQueuedLogger } from './logger';\nimport { getSaveContent } from '../serializer';\nimport { normalizeBlockType } from '../utils';\n\n/**\n * Globally matches any consecutive whitespace\n *\n * @type {RegExp}\n */\nconst REGEXP_WHITESPACE = /[\\t\\n\\r\\v\\f ]+/g;\n\n/**\n * Matches a string containing only whitespace\n *\n * @type {RegExp}\n */\nconst REGEXP_ONLY_WHITESPACE = /^[\\t\\n\\r\\v\\f ]*$/;\n\n/**\n * Matches a CSS URL type value\n *\n * @type {RegExp}\n */\nconst REGEXP_STYLE_URL_TYPE = /^url\\s*\\(['\"\\s]*(.*?)['\"\\s]*\\)$/;\n\n/**\n * Boolean attributes are attributes whose presence as being assigned is\n * meaningful, even if only empty.\n *\n * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\n * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n *\n * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )\n *     .filter( ( tr ) => tr.lastChild.textContent.indexOf( 'Boolean attribute' ) !== -1 )\n *     .reduce( ( result, tr ) => Object.assign( result, {\n *         [ tr.firstChild.textContent.trim() ]: true\n *     } ), {} ) ).sort();\n *\n * @type {Array}\n */\nconst BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'allowpaymentrequest',\n\t'allowusermedia',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'defer',\n\t'disabled',\n\t'download',\n\t'formnovalidate',\n\t'hidden',\n\t'ismap',\n\t'itemscope',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'selected',\n\t'typemustmatch',\n];\n\n/**\n * Enumerated attributes are attributes which must be of a specific value form.\n * Like boolean attributes, these are meaningful if specified, even if not of a\n * valid enumerated value.\n *\n * See: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#enumerated-attribute\n * Extracted from: https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n *\n * Object.keys( Array.from( document.querySelectorAll( '#attributes-1 > tbody > tr' ) )\n *     .filter( ( tr ) => /^(\"(.+?)\";?\\s*)+/.test( tr.lastChild.textContent.trim() ) )\n *     .reduce( ( result, tr ) => Object.assign( result, {\n *         [ tr.firstChild.textContent.trim() ]: true\n *     } ), {} ) ).sort();\n *\n * @type {Array}\n */\nconst ENUMERATED_ATTRIBUTES = [\n\t'autocapitalize',\n\t'autocomplete',\n\t'charset',\n\t'contenteditable',\n\t'crossorigin',\n\t'decoding',\n\t'dir',\n\t'draggable',\n\t'enctype',\n\t'formenctype',\n\t'formmethod',\n\t'http-equiv',\n\t'inputmode',\n\t'kind',\n\t'method',\n\t'preload',\n\t'scope',\n\t'shape',\n\t'spellcheck',\n\t'translate',\n\t'type',\n\t'wrap',\n];\n\n/**\n * Meaningful attributes are those who cannot be safely ignored when omitted in\n * one HTML markup string and not another.\n *\n * @type {Array}\n */\nconst MEANINGFUL_ATTRIBUTES = [\n\t...BOOLEAN_ATTRIBUTES,\n\t...ENUMERATED_ATTRIBUTES,\n];\n\n/**\n * Array of functions which receive a text string on which to apply normalizing\n * behavior for consideration in text token equivalence, carefully ordered from\n * least-to-most expensive operations.\n *\n * @type {Array}\n */\nconst TEXT_NORMALIZATIONS = [ identity, getTextWithCollapsedWhitespace ];\n\n/**\n * Regular expression matching a named character reference. In lieu of bundling\n * a full set of references, the pattern covers the minimal necessary to test\n * positively against the full set.\n *\n * \"The ampersand must be followed by one of the names given in the named\n * character references section, using the same case.\"\n *\n * Tested aginst \"12.5 Named character references\":\n *\n * ```\n * const references = Array.from( document.querySelectorAll(\n *     '#named-character-references-table tr[id^=entity-] td:first-child'\n * ) ).map( ( code ) => code.textContent )\n * references.every( ( reference ) => /^[\\da-z]+$/i.test( reference ) )\n * ```\n *\n * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references\n * @see https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references\n *\n * @type {RegExp}\n */\nconst REGEXP_NAMED_CHARACTER_REFERENCE = /^[\\da-z]+$/i;\n\n/**\n * Regular expression matching a decimal character reference.\n *\n * \"The ampersand must be followed by a U+0023 NUMBER SIGN character (#),\n * followed by one or more ASCII digits, representing a base-ten integer\"\n *\n * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references\n *\n * @type {RegExp}\n */\nconst REGEXP_DECIMAL_CHARACTER_REFERENCE = /^#\\d+$/;\n\n/**\n * Regular expression matching a hexadecimal character reference.\n *\n * \"The ampersand must be followed by a U+0023 NUMBER SIGN character (#), which\n * must be followed by either a U+0078 LATIN SMALL LETTER X character (x) or a\n * U+0058 LATIN CAPITAL LETTER X character (X), which must then be followed by\n * one or more ASCII hex digits, representing a hexadecimal integer\"\n *\n * @see https://html.spec.whatwg.org/multipage/syntax.html#character-references\n *\n * @type {RegExp}\n */\nconst REGEXP_HEXADECIMAL_CHARACTER_REFERENCE = /^#x[\\da-f]+$/i;\n\n/**\n * Returns true if the given string is a valid character reference segment, or\n * false otherwise. The text should be stripped of `&` and `;` demarcations.\n *\n * @param {string} text Text to test.\n *\n * @return {boolean} Whether text is valid character reference.\n */\nexport function isValidCharacterReference( text ) {\n\treturn (\n\t\tREGEXP_NAMED_CHARACTER_REFERENCE.test( text ) ||\n\t\tREGEXP_DECIMAL_CHARACTER_REFERENCE.test( text ) ||\n\t\tREGEXP_HEXADECIMAL_CHARACTER_REFERENCE.test( text )\n\t);\n}\n\n/**\n * Subsitute EntityParser class for `simple-html-tokenizer` which uses the\n * implementation of `decodeEntities` from `html-entities`, in order to avoid\n * bundling a massive named character reference.\n *\n * @see https://github.com/tildeio/simple-html-tokenizer/tree/master/src/entity-parser.ts\n */\nexport class DecodeEntityParser {\n\t/**\n\t * Returns a substitute string for an entity string sequence between `&`\n\t * and `;`, or undefined if no substitution should occur.\n\t *\n\t * @param {string} entity Entity fragment discovered in HTML.\n\t *\n\t * @return {?string} Entity substitute value.\n\t */\n\tparse( entity ) {\n\t\tif ( isValidCharacterReference( entity ) ) {\n\t\t\treturn decodeEntities( '&' + entity + ';' );\n\t\t}\n\t}\n}\n\n/**\n * Given a specified string, returns an array of strings split by consecutive\n * whitespace, ignoring leading or trailing whitespace.\n *\n * @param {string} text Original text.\n *\n * @return {string[]} Text pieces split on whitespace.\n */\nexport function getTextPiecesSplitOnWhitespace( text ) {\n\treturn text.trim().split( REGEXP_WHITESPACE );\n}\n\n/**\n * Given a specified string, returns a new trimmed string where all consecutive\n * whitespace is collapsed to a single space.\n *\n * @param {string} text Original text.\n *\n * @return {string} Trimmed text with consecutive whitespace collapsed.\n */\nexport function getTextWithCollapsedWhitespace( text ) {\n\t// This is an overly simplified whitespace comparison. The specification is\n\t// more prescriptive of whitespace behavior in inline and block contexts.\n\t//\n\t// See: https://medium.com/@patrickbrosset/when-does-white-space-matter-in-html-b90e8a7cdd33\n\treturn getTextPiecesSplitOnWhitespace( text ).join( ' ' );\n}\n\n/**\n * Returns attribute pairs of the given StartTag token, including only pairs\n * where the value is non-empty or the attribute is a boolean attribute, an\n * enumerated attribute, or a custom data- attribute.\n *\n * @see MEANINGFUL_ATTRIBUTES\n *\n * @param {Object} token StartTag token.\n *\n * @return {Array[]} Attribute pairs.\n */\nexport function getMeaningfulAttributePairs( token ) {\n\treturn token.attributes.filter( ( pair ) => {\n\t\tconst [ key, value ] = pair;\n\t\treturn (\n\t\t\tvalue ||\n\t\t\tkey.indexOf( 'data-' ) === 0 ||\n\t\t\tincludes( MEANINGFUL_ATTRIBUTES, key )\n\t\t);\n\t} );\n}\n\n/**\n * Returns true if two text tokens (with `chars` property) are equivalent, or\n * false otherwise.\n *\n * @param {Object} actual   Actual token.\n * @param {Object} expected Expected token.\n * @param {Object} logger   Validation logger object.\n *\n * @return {boolean} Whether two text tokens are equivalent.\n */\nexport function isEquivalentTextTokens(\n\tactual,\n\texpected,\n\tlogger = createLogger()\n) {\n\t// This function is intentionally written as syntactically \"ugly\" as a hot\n\t// path optimization. Text is progressively normalized in order from least-\n\t// to-most operationally expensive, until the earliest point at which text\n\t// can be confidently inferred as being equal.\n\tlet actualChars = actual.chars;\n\tlet expectedChars = expected.chars;\n\n\tfor ( let i = 0; i < TEXT_NORMALIZATIONS.length; i++ ) {\n\t\tconst normalize = TEXT_NORMALIZATIONS[ i ];\n\n\t\tactualChars = normalize( actualChars );\n\t\texpectedChars = normalize( expectedChars );\n\n\t\tif ( actualChars === expectedChars ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tlogger.warning(\n\t\t'Expected text `%s`, saw `%s`.',\n\t\texpected.chars,\n\t\tactual.chars\n\t);\n\n\treturn false;\n}\n\n/**\n * Given a style value, returns a normalized style value for strict equality\n * comparison.\n *\n * @param {string} value Style value.\n *\n * @return {string} Normalized style value.\n */\nexport function getNormalizedStyleValue( value ) {\n\treturn (\n\t\tvalue\n\t\t\t// Normalize URL type to omit whitespace or quotes\n\t\t\t.replace( REGEXP_STYLE_URL_TYPE, 'url($1)' )\n\t);\n}\n\n/**\n * Given a style attribute string, returns an object of style properties.\n *\n * @param {string} text Style attribute.\n *\n * @return {Object} Style properties.\n */\nexport function getStyleProperties( text ) {\n\tconst pairs = text\n\t\t// Trim ending semicolon (avoid including in split)\n\t\t.replace( /;?\\s*$/, '' )\n\t\t// Split on property assignment\n\t\t.split( ';' )\n\t\t// For each property assignment...\n\t\t.map( ( style ) => {\n\t\t\t// ...split further into key-value pairs\n\t\t\tconst [ key, ...valueParts ] = style.split( ':' );\n\t\t\tconst value = valueParts.join( ':' );\n\n\t\t\treturn [ key.trim(), getNormalizedStyleValue( value.trim() ) ];\n\t\t} );\n\n\treturn fromPairs( pairs );\n}\n\n/**\n * Attribute-specific equality handlers\n *\n * @type {Object}\n */\nexport const isEqualAttributesOfName = {\n\tclass: ( actual, expected ) => {\n\t\t// Class matches if members are the same, even if out of order or\n\t\t// superfluous whitespace between.\n\t\treturn ! xor(\n\t\t\t...[ actual, expected ].map( getTextPiecesSplitOnWhitespace )\n\t\t).length;\n\t},\n\tstyle: ( actual, expected ) => {\n\t\treturn isEqual( ...[ actual, expected ].map( getStyleProperties ) );\n\t},\n\t// For each boolean attribute, mere presence of attribute in both is enough\n\t// to assume equivalence.\n\t...fromPairs(\n\t\tBOOLEAN_ATTRIBUTES.map( ( attribute ) => [ attribute, stubTrue ] )\n\t),\n};\n\n/**\n * Given two sets of attribute tuples, returns true if the attribute sets are\n * equivalent.\n *\n * @param {Array[]} actual   Actual attributes tuples.\n * @param {Array[]} expected Expected attributes tuples.\n * @param {Object}  logger   Validation logger object.\n *\n * @return {boolean} Whether attributes are equivalent.\n */\nexport function isEqualTagAttributePairs(\n\tactual,\n\texpected,\n\tlogger = createLogger()\n) {\n\t// Attributes is tokenized as tuples. Their lengths should match. This also\n\t// avoids us needing to check both attributes sets, since if A has any keys\n\t// which do not exist in B, we know the sets to be different.\n\tif ( actual.length !== expected.length ) {\n\t\tlogger.warning(\n\t\t\t'Expected attributes %o, instead saw %o.',\n\t\t\texpected,\n\t\t\tactual\n\t\t);\n\t\treturn false;\n\t}\n\n\t// Attributes are not guaranteed to occur in the same order. For validating\n\t// actual attributes, first convert the set of expected attribute values to\n\t// an object, for lookup by key.\n\tconst expectedAttributes = {};\n\tfor ( let i = 0; i < expected.length; i++ ) {\n\t\texpectedAttributes[ expected[ i ][ 0 ].toLowerCase() ] =\n\t\t\texpected[ i ][ 1 ];\n\t}\n\n\tfor ( let i = 0; i < actual.length; i++ ) {\n\t\tconst [ name, actualValue ] = actual[ i ];\n\t\tconst nameLower = name.toLowerCase();\n\n\t\t// As noted above, if missing member in B, assume different\n\t\tif ( ! expectedAttributes.hasOwnProperty( nameLower ) ) {\n\t\t\tlogger.warning( 'Encountered unexpected attribute `%s`.', name );\n\t\t\treturn false;\n\t\t}\n\n\t\tconst expectedValue = expectedAttributes[ nameLower ];\n\t\tconst isEqualAttributes = isEqualAttributesOfName[ nameLower ];\n\n\t\tif ( isEqualAttributes ) {\n\t\t\t// Defer custom attribute equality handling\n\t\t\tif ( ! isEqualAttributes( actualValue, expectedValue ) ) {\n\t\t\t\tlogger.warning(\n\t\t\t\t\t'Expected attribute `%s` of value `%s`, saw `%s`.',\n\t\t\t\t\tname,\n\t\t\t\t\texpectedValue,\n\t\t\t\t\tactualValue\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if ( actualValue !== expectedValue ) {\n\t\t\t// Otherwise strict inequality should bail\n\t\t\tlogger.warning(\n\t\t\t\t'Expected attribute `%s` of value `%s`, saw `%s`.',\n\t\t\t\tname,\n\t\t\t\texpectedValue,\n\t\t\t\tactualValue\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Token-type-specific equality handlers\n *\n * @type {Object}\n */\nexport const isEqualTokensOfType = {\n\tStartTag: ( actual, expected, logger = createLogger() ) => {\n\t\tif (\n\t\t\tactual.tagName !== expected.tagName &&\n\t\t\t// Optimization: Use short-circuit evaluation to defer case-\n\t\t\t// insensitive check on the assumption that the majority case will\n\t\t\t// have exactly equal tag names.\n\t\t\tactual.tagName.toLowerCase() !== expected.tagName.toLowerCase()\n\t\t) {\n\t\t\tlogger.warning(\n\t\t\t\t'Expected tag name `%s`, instead saw `%s`.',\n\t\t\t\texpected.tagName,\n\t\t\t\tactual.tagName\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn isEqualTagAttributePairs(\n\t\t\t...[ actual, expected ].map( getMeaningfulAttributePairs ),\n\t\t\tlogger\n\t\t);\n\t},\n\tChars: isEquivalentTextTokens,\n\tComment: isEquivalentTextTokens,\n};\n\n/**\n * Given an array of tokens, returns the first token which is not purely\n * whitespace.\n *\n * Mutates the tokens array.\n *\n * @param {Object[]} tokens Set of tokens to search.\n *\n * @return {Object} Next non-whitespace token.\n */\nexport function getNextNonWhitespaceToken( tokens ) {\n\tlet token;\n\twhile ( ( token = tokens.shift() ) ) {\n\t\tif ( token.type !== 'Chars' ) {\n\t\t\treturn token;\n\t\t}\n\n\t\tif ( ! REGEXP_ONLY_WHITESPACE.test( token.chars ) ) {\n\t\t\treturn token;\n\t\t}\n\t}\n}\n\n/**\n * Tokenize an HTML string, gracefully handling any errors thrown during\n * underlying tokenization.\n *\n * @param {string} html   HTML string to tokenize.\n * @param {Object} logger Validation logger object.\n *\n * @return {Object[]|null} Array of valid tokenized HTML elements, or null on error\n */\nfunction getHTMLTokens( html, logger = createLogger() ) {\n\ttry {\n\t\treturn new Tokenizer( new DecodeEntityParser() ).tokenize( html );\n\t} catch ( e ) {\n\t\tlogger.warning( 'Malformed HTML detected: %s', html );\n\t}\n\n\treturn null;\n}\n\n/**\n * Returns true if the next HTML token closes the current token.\n *\n * @param {Object} currentToken Current token to compare with.\n * @param {Object|undefined} nextToken Next token to compare against.\n *\n * @return {boolean} true if `nextToken` closes `currentToken`, false otherwise\n */\nexport function isClosedByToken( currentToken, nextToken ) {\n\t// Ensure this is a self closed token\n\tif ( ! currentToken.selfClosing ) {\n\t\treturn false;\n\t}\n\n\t// Check token names and determine if nextToken is the closing tag for currentToken\n\tif (\n\t\tnextToken &&\n\t\tnextToken.tagName === currentToken.tagName &&\n\t\tnextToken.type === 'EndTag'\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Returns true if the given HTML strings are effectively equivalent, or\n * false otherwise. Invalid HTML is not considered equivalent, even if the\n * strings directly match.\n *\n * @param {string} actual   Actual HTML string.\n * @param {string} expected Expected HTML string.\n * @param {Object} logger   Validation logger object.\n *\n * @return {boolean} Whether HTML strings are equivalent.\n */\nexport function isEquivalentHTML( actual, expected, logger = createLogger() ) {\n\t// Short-circuit if markup is identical.\n\tif ( actual === expected ) {\n\t\treturn true;\n\t}\n\n\t// Tokenize input content and reserialized save content\n\tconst [ actualTokens, expectedTokens ] = [\n\t\tactual,\n\t\texpected,\n\t].map( ( html ) => getHTMLTokens( html, logger ) );\n\n\t// If either is malformed then stop comparing - the strings are not equivalent\n\tif ( ! actualTokens || ! expectedTokens ) {\n\t\treturn false;\n\t}\n\n\tlet actualToken, expectedToken;\n\twhile ( ( actualToken = getNextNonWhitespaceToken( actualTokens ) ) ) {\n\t\texpectedToken = getNextNonWhitespaceToken( expectedTokens );\n\n\t\t// Inequal if exhausted all expected tokens\n\t\tif ( ! expectedToken ) {\n\t\t\tlogger.warning(\n\t\t\t\t'Expected end of content, instead saw %o.',\n\t\t\t\tactualToken\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Inequal if next non-whitespace token of each set are not same type\n\t\tif ( actualToken.type !== expectedToken.type ) {\n\t\t\tlogger.warning(\n\t\t\t\t'Expected token of type `%s` (%o), instead saw `%s` (%o).',\n\t\t\t\texpectedToken.type,\n\t\t\t\texpectedToken,\n\t\t\t\tactualToken.type,\n\t\t\t\tactualToken\n\t\t\t);\n\t\t\treturn false;\n\t\t}\n\n\t\t// Defer custom token type equality handling, otherwise continue and\n\t\t// assume as equal\n\t\tconst isEqualTokens = isEqualTokensOfType[ actualToken.type ];\n\t\tif (\n\t\t\tisEqualTokens &&\n\t\t\t! isEqualTokens( actualToken, expectedToken, logger )\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Peek at the next tokens (actual and expected) to see if they close\n\t\t// a self-closing tag\n\t\tif ( isClosedByToken( actualToken, expectedTokens[ 0 ] ) ) {\n\t\t\t// Consume the next expected token that closes the current actual\n\t\t\t// self-closing token\n\t\t\tgetNextNonWhitespaceToken( expectedTokens );\n\t\t} else if ( isClosedByToken( expectedToken, actualTokens[ 0 ] ) ) {\n\t\t\t// Consume the next actual token that closes the current expected\n\t\t\t// self-closing token\n\t\t\tgetNextNonWhitespaceToken( actualTokens );\n\t\t}\n\t}\n\n\tif ( ( expectedToken = getNextNonWhitespaceToken( expectedTokens ) ) ) {\n\t\t// If any non-whitespace tokens remain in expected token set, this\n\t\t// indicates inequality\n\t\tlogger.warning(\n\t\t\t'Expected %o, instead saw end of content.',\n\t\t\texpectedToken\n\t\t);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns an object with `isValid` property set to `true` if the parsed block\n * is valid given the input content. A block is considered valid if, when serialized\n * with assumed attributes, the content matches the original value. If block is\n * invalid, this function returns all validations issues as well.\n *\n * @param {string|Object} blockTypeOrName      Block type.\n * @param {Object}        attributes           Parsed block attributes.\n * @param {string}        originalBlockContent Original block content.\n * @param {Object}        logger           \t   Validation logger object.\n *\n * @return {Object} Whether block is valid and contains validation messages.\n */\nexport function getBlockContentValidationResult(\n\tblockTypeOrName,\n\tattributes,\n\toriginalBlockContent,\n\tlogger = createQueuedLogger()\n) {\n\tconst blockType = normalizeBlockType( blockTypeOrName );\n\tlet generatedBlockContent;\n\ttry {\n\t\tgeneratedBlockContent = getSaveContent( blockType, attributes );\n\t} catch ( error ) {\n\t\tlogger.error(\n\t\t\t'Block validation failed because an error occurred while generating block content:\\n\\n%s',\n\t\t\terror.toString()\n\t\t);\n\n\t\treturn {\n\t\t\tisValid: false,\n\t\t\tvalidationIssues: logger.getItems(),\n\t\t};\n\t}\n\n\tconst isValid = isEquivalentHTML(\n\t\toriginalBlockContent,\n\t\tgeneratedBlockContent,\n\t\tlogger\n\t);\n\tif ( ! isValid ) {\n\t\tlogger.error(\n\t\t\t'Block validation failed for `%s` (%o).\\n\\nContent generated by `save` function:\\n\\n%s\\n\\nContent retrieved from post body:\\n\\n%s',\n\t\t\tblockType.name,\n\t\t\tblockType,\n\t\t\tgeneratedBlockContent,\n\t\t\toriginalBlockContent\n\t\t);\n\t}\n\n\treturn {\n\t\tisValid,\n\t\tvalidationIssues: logger.getItems(),\n\t};\n}\n\n/**\n * Returns true if the parsed block is valid given the input content. A block\n * is considered valid if, when serialized with assumed attributes, the content\n * matches the original value.\n *\n * Logs to console in development environments when invalid.\n *\n * @param {string|Object} blockTypeOrName      Block type.\n * @param {Object}        attributes           Parsed block attributes.\n * @param {string}        originalBlockContent Original block content.\n *\n * @return {boolean} Whether block is valid.\n */\nexport function isValidBlockContent(\n\tblockTypeOrName,\n\tattributes,\n\toriginalBlockContent\n) {\n\tconst { isValid } = getBlockContentValidationResult(\n\t\tblockTypeOrName,\n\t\tattributes,\n\t\toriginalBlockContent,\n\t\tcreateLogger()\n\t);\n\n\treturn isValid;\n}\n"]}